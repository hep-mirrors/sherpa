#ifndef BEAM_Main_EPA_H
#define BEAM_Main_EPA_H

#include "BEAM/Main/Beam_Base.H"
#include "ATOOLS/Math/Function_Base.H"
#include "ATOOLS/Math/Lookup_Tables.H"

namespace ATOOLS { class Settings; }

namespace BEAM {
  enum class EPA_ff_type {
    point      = 0,
    Gauss      = 1,
    dipole     = 2,
    hcs        = 11,
    smooth_hcs = 12,
    WoodSaxon  = 13
  };
  
  class EPA_FF_Base {
  protected:
    ATOOLS::Flavour m_beam;
    double          m_mass, m_E, m_q2min, m_q2max, m_pt2max;
    ATOOLS::OneDim_Table * p_FF_Q2;
  public:
    EPA_FF_Base(const ATOOLS::Flavour & beam, const double & E) :
      m_beam(beam), m_mass(m_beam.Mass(true)), m_E(E),
      m_q2min(0.), m_q2max(1.e99), m_pt2max(-1.), p_FF_Q2(nullptr) {}
    virtual const double operator()(const double & x,const double & Q2=-1.)   = 0;
    virtual const double N(const double & x)                                  = 0;
    virtual const double FF(const double & Q2) { return 1.; }
    virtual       void   SetSwitch(const std::string & tag,const size_t & sw) {}
    virtual       void   SetParam(const std::string & tag,const double & val) {}

    virtual const ATOOLS::Flavour & Flav() const { return m_beam; } 
    virtual const double            Mass() const { return m_beam.Mass(); } 
    virtual void  SetPT2Max(const double & pt2max) { m_pt2max = pt2max; } 
    virtual void  SetQ2Min(const double & q2min)   { m_q2min  = q2min; } 
    virtual void  SetQ2Max(const double & q2max)   { m_q2max  = q2max; }
    
    inline virtual const double Q2min(const double & x) const {
      return ATOOLS::Max(m_q2min,ATOOLS::sqr(m_mass*x)/(1-x));
    }
    // Use maximal angle for the scattered electron in Q^2_max,
    // compare with hep-ph/9610406 and hep-ph/9310350 for the 
    // inclusion of term ~(x m)^2
    inline virtual const double Q2max(const double & x) const {
      return ( (m_pt2max>0.) ?
	       ATOOLS::Min(m_q2max,ATOOLS::sqr(m_mass*x)/(1-x)+m_pt2max*(1.-x)) :
	       m_q2max );
    }

  };

  class EPA_Point : public EPA_FF_Base {
  private:
    size_t m_approx;
  public:
    EPA_Point(const ATOOLS::Flavour & beam, const double & E) :
      EPA_FF_Base(beam,E), m_approx(1) {}
    const  double operator()(const double & x,const double & Q2=-1.) { return 1.; }
    const  double N(const double & x);
    inline void   SetSwitch(const std::string & tag,const size_t & sw) {
      if (tag=="approximation") m_approx = sw;
    }
  };

  class EPA_Dipole : public EPA_FF_Base {
  private:
    size_t m_approx;
    double m_mass2, m_Lambda2, m_mu2, m_aDip, m_bDip, m_cDip;
    void SetABC();
    const double phi(const double & y,const double & arg);
  public:
    EPA_Dipole(const ATOOLS::Flavour & beam, const double & E) :
      EPA_FF_Base(beam,E), m_approx(1), m_Lambda2(1.) {
      m_mass2 = ATOOLS::sqr(m_mass);
      if (m_beam==ATOOLS::Flavour(kf_p_plus)) { m_mu2 = 2.79*2.79; m_Lambda2 = 0.71; }
      SetABC();
    }
    const  double operator()(const double & x,const double & Q2=-1.);
    const  double N(const double & x);
    inline void   SetParam(const std::string & tag,const double & value) {
      if (tag=="Lambda2") m_Lambda2 = value;
      if (tag=="Mu2")     m_mu2     = value;
      SetABC();
    }
    inline void  SetSwitch(const std::string & tag,size_t sw) {
      if (tag=="approximation") m_approx = sw;
    }
  };

  class EPA_Gauss : public EPA_FF_Base {
  private:
    size_t m_approx;
    double m_mass2, m_Q02, m_mu2;
  public:
    EPA_Gauss(const ATOOLS::Flavour & beam, const double & E);
    const double operator()(const double & x,const double & Q2);
    const double N(const double & x);
    const double FF(const double & Q2) { return exp(-Q2/m_Q02); }
    inline void   SetParam(const std::string & tag,const double & value) {
      if (tag=="Q02") m_Q02 = value;
      if (tag=="Mu2") m_mu2 = value;
    }
    inline void  SetSwitch(const std::string & tag,size_t sw) {
      if (tag=="approximation") m_approx = sw;
    }
  };

  class EPA_WoodSaxon : public EPA_FF_Base {
  private:
    class Rho_argument : public ATOOLS::Function_Base {
    private:
      double m_R, m_d;
    public:
      Rho_argument(const double & R,const double & d) : m_R(R), m_d(d) {}
      double operator()(double r) { return 4.*M_PI*r*r/(1.+exp((r-m_R)/m_d)); }
    };
    
    class WS_argument : public ATOOLS::Function_Base {
    private:
      double m_R, m_d, m_q;
    public:
      WS_argument(const double & R,const double & d) : m_R(R), m_d(d), m_q(1.) {}
      inline void SetQ(const double & q) { m_q = q; }
      double operator()(double r) {
	if (m_q*r<1.e-6) return 4.*M_PI*r*r/(1.+exp((r-m_R)/m_d));
	return 4.*M_PI*sin(m_q*r)/m_q*r/(1.+exp((r-m_R)/m_d));
      }
    };

    size_t m_A, m_Z;
    double m_mass2, m_R, m_d, m_rho0;
    
    double CalculateDensity();
    void   InitFFTable(const double & q2min,const double & q2max);
  public:
    EPA_WoodSaxon(const ATOOLS::Flavour & beam, const double & E);
    const double operator()(const double & x,const double & Q2);
    const double N(const double & x);
    const double FF(const double & Q2) { return (*p_FF_Q2)(Q2); }
  };

  
  class EPA final : public Beam_Base {
  private:
    EPA_ff_type   m_type;
    EPA_FF_Base * p_ff;
    double m_mass, m_charge, m_gamma;
    double m_q2max, m_q2min, m_theta_max, m_pt2max, m_pt2min;
    double m_xmin, m_xmax, m_bmin, m_bmax;
    double m_aqed, m_pref;
    size_t m_approx;
    size_t m_nxbins, m_nbbins;
    bool   m_analytic;

    ATOOLS::OneDim_Table * p_N_x;
    ATOOLS::TwoDim_Table * p_N_xb;

    void   Initialise();
    void   RegisterDefaults() const;
    void   InitFormFactor(ATOOLS::Settings &s);
    double ExtractParameter(ATOOLS::Settings &s,const std::string & tag);
    void   WriteDebugFiles(ATOOLS::Settings &s);

    void   InitTables();
    void   InitdN_by_dx();
    void   TestIntegration();

    double Point(const double & x);
    double phi(double x, double qq) const;
    void   selfTest(const std::string& filename);

    void   WriteFiles();
    void   WriteIonFFsFiles();
    void   WriteLeptonFiles();
    void   WriteProtonFiles();
  public:

    EPA(const ATOOLS::Flavour beam,const double energy,const double pol,
	const int dir);

    ~EPA() override = default;

    Beam_Base *Copy() override { return new EPA(*this); }

    inline bool CalculateWeight(double x, double Q2=-1) override {
      m_weight = (*this)(x); return true;
    }
    inline const double operator()(const double & x) {
      return ( (x>=m_xmin && x<=m_xmax) ?
	       ATOOLS::Max(0., m_pref/x*p_ff->N(x)) : 0. ); 
    }
    void FixPosition() override;
    void SetOutMomentum(const ATOOLS::Vec4D &out, const size_t & i=0) override;
    inline double Xmax() const override { return m_xmax; }
    inline double Xmin() const override { return m_xmin; }
  };// end of class EPA


  

  class KperpIntegrand : public ATOOLS::Function_Base {
  private:
    EPA_FF_Base * p_ff;
    size_t m_mode;
    double m_mass, m_x, m_bT;
  public:
    KperpIntegrand(EPA_FF_Base * ff, const size_t & mode=0) :
      p_ff(ff), m_mode(mode), m_mass(p_ff->Mass()), m_x(1.), m_bT(0.) {}
    double operator()(double kT);
    inline const double & Mass() const { return m_mass; }
    inline const double & X()    const { return m_x; }
    inline void   SetMass(const double & mass) { m_mass = mass; }
    inline void   SetX(const double & x)       { m_x    = x; }
    inline void   SetBT(const double & bT)     { m_bT   = bT; }
    inline void   SetMode(const bool & mode)   { m_mode = mode; }
  };
  
  class BIntegrand : public ATOOLS::Function_Base {
  private:
    ATOOLS::TwoDim_Table * p_N_xb;
    double m_x;
  public:
    BIntegrand(ATOOLS::TwoDim_Table * N_xb) : p_N_xb(N_xb), m_x(1.) {} 
    double operator()(double b)   { return 2.*M_PI*b*(*p_N_xb)(m_x,b); }
    void   SetX(const double & x) { m_x = x; }
  };

  //////////////////////////////////////////////////////////////////////
  //
  // A class to implement the integration over the product of a smooth
  // non-oscillatory function and a oscillatory function, according to
  // - S.K. Lucas, H.A. Stone, Journal of Computational and Applied
  //   Mathematics 64 (1995) 217-231; implementing mainly the method of
  // - A.Sidi, Mathematics of Computation 51 183 (1988) 249-266. 
  //
  /////////////////////////////////////////////////////////////////////
  
}// end of namespace BEAM



/*
      class CosInt final : public ATOOLS::Function_Base {
    public:
      double GetValue(double T) override { return -cos(T)/T; }
      double operator()(double T) override { return GetValue(T); }
      double GetCosInt(double X);
    };

 */
#endif
