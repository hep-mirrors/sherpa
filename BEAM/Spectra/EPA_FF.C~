#include "BEAM/Spectra/EPA.H"
#include "BEAM/Spectra/EPA_FF.H"

#include "ATOOLS/Math/Special_Functions.H"
#include "ATOOLS/Math/MathTools.H"
#include "ATOOLS/Math/Bessel_Integrator.H"
#include "ATOOLS/Math/Gauss_Integrator.H"
#include "ATOOLS/Math/Random.H"
#include "ATOOLS/Org/Exception.H"
#include "ATOOLS/Org/Message.H"
#include "ATOOLS/Org/Run_Parameter.H"
#include "ATOOLS/Org/MyStrStream.H"
#include "ATOOLS/Org/My_File.H"
#include "ATOOLS/Org/Settings.H"

#include <fstream>
#include <string>

using namespace BEAM;
using namespace ATOOLS;
using namespace std;

ATOOLS::Special_Functions ATOOLS::SF;

EPA::EPA(const Flavour beam, const double energy, const double pol, const int dir) :
  Beam_Base(beamspectrum::EPA, beam, energy, pol, dir),
  m_type(EPA_ff_type::point), p_ff(nullptr), 
  m_mass(m_beam.Mass(true)), m_charge(m_beam.Charge()), m_gamma(m_energy/m_mass)
{
  Initialise();
  m_Nbunches   = 2;
  m_bunches.resize(m_Nbunches);
  m_bunches[0] = Flavour(kf_photon);
  m_bunches[1] = m_beam;
  m_vecouts.resize(m_Nbunches);
  m_vecouts[0] = Vec4D(m_energy, 0., 0., m_dir * m_energy);
  m_vecouts[1] = Vec4D(0.,0.,0.,0.);
  m_on         = true;
}

void EPA::FixPosition() {
  /*
  // This is a bit of a poor-man's choice for a point-like source,
  // with a minmimal distance m_minR ... we would need some notion of
  // off'shellness here ...
  double ratio = m_maxR/m_minR, logratio = log(ratio), R, phi;
  if (ran->Get()< logratio/(0.5+logratio)) {
    R = m_minR * pow(ratio,ran->Get());
  }
  else {
    R = m_minR * sqrt(ran->Get());
  }
  phi = 2.*M_PI*ran->Get();
  m_position = R * Vec4D(0., cos(phi), sin(phi), 0.);
  */
}

void EPA::SetOutMomentum(const ATOOLS::Vec4D &out, const size_t & i) {
  if (i==0) {
    m_vecouts[0] = out;
    m_vecouts[1] = m_lab-out;
  }
}

void EPA::WriteFiles() {
  WriteIonFFsFiles();
  WriteLeptonFiles();
  WriteProtonFiles();
  exit(1);
}

void EPA::WriteIonFFsFiles() {
  vector<EPA_FF_Base * > ffs;
  ffs.push_back(new EPA_Gauss(kf_lead208,2360));
  ffs.push_back(new EPA_WoodSaxon(kf_lead208,2360));
  My_Out_File ofile("LeadFormFactors.dat");
  ofile.Open();
  for (size_t q=0;q<100000;q++) {
    double q2 = double(q)/double(100000);
    msg_Out()<<q2<<": ";
    (*ofile)<<q2<<" ";
    for (size_t i=0;i<ffs.size();i++) {
      msg_Out()<<ffs[i]->FF(q2)<<" ";
      (*ofile)<<ffs[i]->FF(q2)<<" ";
    }
    msg_Out()<<"\n";
    (*ofile)<<"\n";
  }
  ofile.Close();
  while (!ffs.empty()) { delete ffs.back(); ffs.pop_back(); }
}

void EPA::WriteProtonFiles() {
  map<string,double> pp_setups;
  pp_setups["LHC_13000"]     = 6500.;
  pp_setups["Tevatron_1960"] = 980.;
  vector<string> pp_ffs;
  pp_ffs.push_back("Point");
  pp_ffs.push_back("Dipole");
  pp_ffs.push_back("Gauss");
  vector<double> pp_Q2max;
  pp_Q2max.push_back(sqr(4.));
  double omegamin = 5., maxratio = 0.2;
  size_t n_obins  = 200.;

  for (size_t i=7;i>0;i--)
    msg_Out()<<METHOD<<" tests Ei(-"<<1./pow(10.,i)<<") = "
	     <<SF.IncompleteGamma(0,1./pow(10.,i))<<"\n";
  for (size_t i=1;i<6;i++)
    msg_Out()<<METHOD<<" tests Ei(-"<<i<<") = "<<SF.IncompleteGamma(0,double(i))<<"\n";
  for (map<string, double>::iterator sit=pp_setups.begin();
       sit!=pp_setups.end();sit++) {
    for (vector<string>::iterator ffit=pp_ffs.begin();
	 ffit!=pp_ffs.end();ffit++) {
      for (size_t q=0;q<pp_Q2max.size();q++) {
	double E     = sit->second;
	double Q2max = pp_Q2max[q];
	double step  = log(maxratio*E/omegamin)/double(n_obins);
	if ((*ffit)=="Point")  p_ff = new EPA_Point(Flavour(kf_p_plus),E);
	if ((*ffit)=="Dipole") p_ff = new EPA_Dipole(Flavour(kf_p_plus),E);
	if ((*ffit)=="Gauss")  p_ff = new EPA_Gauss(Flavour(kf_p_plus),E);      
	p_ff->SetQ2Max(Q2max);
	msg_Out()<<METHOD<<" running for "<<sit->first<<" + "<<(*ffit)<<": "
		 <<"|"<<(sit->first+"_"+(*ffit)+"_"+ToString(Q2max)+".dat")<<"|\n";
	My_Out_File ofile(sit->first+"_"+(*ffit)+"_"+ToString(Q2max)+".dat");
	ofile.Open();
	for (size_t i=0;i<n_obins;i++) {
	  double omega   = omegamin*exp( step*double(i) );
	  double x       = omega/E;
	  (*ofile)<<omega<<" "<<x<<" ";
	  for (size_t a=0;a<3;a++) {
	    p_ff->SetSwitch("approximation",a);
	    (*ofile)<<(*this)(x)<<" "<<(x*(*this)(x))<<" ";
	  }
	  (*ofile)<<"\n";
	}
	ofile.Close();
	delete p_ff;
      }
    }
  }
}

void EPA::WriteLeptonFiles() {
  map<string,double> ee_setups;
  ee_setups["LEP_91.2"]    = 45.6;
  ee_setups["FCCee_250.0"] = 125.;
  vector<double> thetamax_ee;
  thetamax_ee.push_back(1.);
  thetamax_ee.push_back(2.);
  thetamax_ee.push_back(5.);
  double omegamin = 2.;
  size_t n_obins = 200.;
  for (map<string, double>::iterator sit=ee_setups.begin();
       sit!=ee_setups.end();sit++) {
    for (size_t th=0;th<thetamax_ee.size();th++) {
      double E      = sit->second;
      double theta  = thetamax_ee[th]*M_PI/180.;
      double pt2max = sqr(E*theta);
      p_ff = new EPA_Point(Flavour(kf_e),E);
      p_ff->SetPT2Max(pt2max);
      My_Out_File ofile(sit->first+"_"+ToString(thetamax_ee[th])+".dat");
      msg_Out()<<METHOD<<" running for "<<sit->first<<" + "<<thetamax_ee[th]<<": "
	       <<"|"<<(sit->first+"_"+ToString(thetamax_ee[th])+".dat")<<"|\n";
      ofile.Open();
      for (size_t i=0;i<n_obins;i++) {
	double omega   = omegamin+double(i)/double(n_obins)*(E-omegamin);
	double x       = omega/E;
	(*ofile)<<omega<<" "<<x<<" ";
	for (size_t a=0;a<3;a++) {
	  p_ff->SetSwitch("approximation",a);
	  (*ofile)<<(*this)(x)<<" "<<(x*(*this)(x))<<" ";
	}
	(*ofile)<<"\n";
      }
      ofile.Close();
      delete p_ff;
    }
  }
}

///////////////////////////////////////////////////////////////////////////////////
//
// Point-like form factors and related functions in different approximations, all
// based on Budnev et al., Phys. Rep. C15 (1974) 181.
//
///////////////////////////////////////////////////////////////////////////////////

const double EPA_Point::N(const double & x) {
  // Budnev et al., Phys. Rep. C15 (1974) 181, Eq. (6.17b)
  double q2min = Q2min(x), q2max = Q2max(x);
  if (q2max<=q2min) {
    msg_Out()<<METHOD<<"("<<x<<") --> q2min = "<<q2min<<", q2max = "<<q2max<<"\n";
    return 0.;
  }
  // First term
  double wt    = (1.+sqr(1.-x))/2. * log(q2max/q2min);
  // Last term
  if (m_approx>=1)
    wt        -= sqr(m_mass*x) * (1./q2min- 1./q2max); 
  // Middle term
  if (m_approx>=2) {
    double e2  = sqr(x*m_E);
    wt        -= sqr(1.-x/2)*log((e2+q2max)/(e2+q2min));
  }
  return wt;
}

///////////////////////////////////////////////////////////////////////////////////
//
// Dipole form factors and related functions in different approximations, all
// based on Budnev et al., Phys. Rep. C15 (1974) 181.
//
///////////////////////////////////////////////////////////////////////////////////

const double EPA_Dipole::operator()(const double & x,const double & Q2) {
  // c.f. V.M. Budnev et al., Phys. Rep. C15(1974)181, Eq. (D.7)
  double q2min = Q2min(x), q2max = Q2max(x), prefC = m_mu2, prefD = 1.;
  if (q2max<=q2min || Q2<q2min || Q2> q2max) return 0.;
  // taking into account Q^2-dependence of form factors by over-riding their
  // value at Q^2 = 0 ...
  if (m_approx>0) {
    prefC = m_mu2/sqr(1.-Q2/m_Lambda2);
    prefD = (4.*m_mass2-Q2*m_mu2)/(4.*m_mass2-Q2)/sqr(1.-Q2/m_Lambda2);
  }
  // ... or ignoring it
  return ( sqr(x)/2.*prefC + (1.-x)*(1.+q2min/Q2)*prefD);
}

void EPA_Dipole::SetABC() {
  // a, b, c coeffients from Budnev et al., Eq. (D.7)
  m_aDip = (1.+m_mu2)/4. + 4.*m_mass2/m_Lambda2;  // should be  7.16
  m_bDip = 1.-4.*m_mass2/m_Lambda2;               // should be -3.96
  m_cDip = (m_mu2-1.)/pow(m_bDip,4.);             // should be  0.028
}

const double EPA_Dipole::phi(const double & y,const double & arg) {
  // phi_i(x) from Budnev et al., Eq. (D.7)
  double pow_arg, sum1=0., sum2=0., addit;
  for (size_t i=0;i<3;i++) {
    pow_arg = pow(1.+arg,i+1);
    sum1   += addit = 1./(double(i+1)*pow_arg);
    sum2   += pow(m_bDip,i+1)*addit;
  }
  return ((1.+m_aDip*y)*(-log(1.+1./arg) + sum1) -
	  (1.-m_bDip)*y/(4.*arg*pow_arg) +
	  m_cDip*(1.+y/4.)*(log((1.+arg-m_bDip)/(1.+arg))+sum2) );
}

const double EPA_Dipole::N(const double & x) {
  // c.f. V.M. Budnev et al., Phys. Rep. C15(1974)181, Eq. (D.7)
  double q2min = Q2min(x), q2max = Q2max(x);
  if (q2max<=q2min) return 0.;
  // taking into account the Q^2-dependence of form factors ...
  if (m_approx>0) {
    double y = sqr(x)/(1.-x);
    return (1.-x)*(phi(y,q2max/m_Lambda2)-phi(y,q2min/m_Lambda2)); 
  }
  // ... or ignoring it.
  return ( (1.-x+m_mu2*sqr(x)/2.)*log(q2max/q2min) -
	   (1.-x)*(1.-q2min/q2max) );
}


///////////////////////////////////////////////////////////////////////////////////
//
// Gaussian form factors replacing the dipole form factors of Budnev et al.,
// Phys. Rep. C15 (1974) 181.
//
///////////////////////////////////////////////////////////////////////////////////

EPA_Gauss::EPA_Gauss(const ATOOLS::Flavour & beam, const double & E) :
  EPA_FF_Base(beam,E), m_approx(1), m_Q02(1.) {
  m_mass2 = ATOOLS::sqr(m_mass);
  if (m_beam==ATOOLS::Flavour(kf_p_plus)) {
    m_mu2 = 2.79*2.79;
    m_Q02 = 0.71;
  }
  else if (m_beam.IsIon()) {
    m_mu2    = 0.;
    double R = 1.2*pow(double(m_beam.GetAtomicNumber()),1./3.)/rpa->hBar_c();
    m_Q02    = sqr(2.5/R);
    msg_Out()<<"Init Gauss for "<<m_beam<<": "
	     <<"R = "<<(1000.*R)<<" 1/MeV = "<<(R*rpa->hBar_c())<<" fm, "
	     <<"Q0^2 = "<<m_Q02<<" GeV^2.\n";
  }
}

const double EPA_Gauss::operator()(const double & x,const double & Q2) {
  // c.f. V.M. Budnev et al., Phys. Rep. C15(1974)181, Eq. (D.7)
  // but modifying the dipole form to a Gaussian form
  double q2min = Q2min(x), q2max = Q2max(x), prefC = m_mu2, prefD = 1.;
  // taking into account Q^2-dependence of form factors by over-riding their
  // value at Q^2 = 0 ...
  if (m_approx>0) {
    prefC = m_mu2*exp(-Q2/m_Q02);
    prefD = exp(-Q2/m_Q02);
  }
  // ... or ignoring it
  return ( sqr(x)/2.*prefC + (1.-x)*(1.+q2min/Q2)*prefD);
}

const double EPA_Gauss::N(const double & x) {
  // c.f. V.M. Budnev et al., Phys. Rep. C15(1974)181, Eq. (D.7)
  double q2min = Q2min(x), q2max = Q2max(x), term1, term2;
  // taking into account the Q^2-dependence of form factors and using that
  // Ei(-x) = -IncompleteGamma(0,x)
  if (m_approx>0) {
    term1 = SF.IncompleteGamma(0,q2min/m_Q02) - SF.IncompleteGamma(0,q2max/m_Q02);
    term2 = term1 -q2min * ( exp(-q2max/m_Q02)/q2max - exp(-q2min/m_Q02)/q2min +
			     1./m_Q02 * term1 );
  }
  // ... or ignoring it.
  else {
    term1 = log(q2max/q2min);
    term2 = term1+q2min*(1./q2max-1./q2min);
  }
  double res = m_mu2*sqr(x)*term1 + (1.-x)*term2; 
  msg_Out()<<METHOD<<"("<<m_approx<<", x = "<<x<<" in ["<<q2min<<", "<<q2max<<"] :"
	   <<term1<<" & "<<term2<<" for Q0^2 = "<<m_Q02<<": "<<res<<".\n";
  return res;
}

///////////////////////////////////////////////////////////////////////////////////
//
// Form factor for ions in a Wood-Saxon potential.  A few comments:
//
// - Output for the density modifed to recover the atomic number A on integration,
//   and in units of fm^-3 or GeV^3.   Internally we normalise it to unity,
//   because we will later multiply the square of the form factor with the square
//   of the charge Z.
// - Radius in 1/GeV, given in fm only for output purposes.
//
///////////////////////////////////////////////////////////////////////////////////

EPA_WoodSaxon::EPA_WoodSaxon(const ATOOLS::Flavour & beam, const double & E) :
  EPA_FF_Base(beam,E) {
  m_mass2 = ATOOLS::sqr(m_mass);
  if (m_beam.IsIon()) {
    m_Z = m_beam.IntCharge();
    m_A = m_beam.GetAtomicNumber();
    m_R = 1.2*pow(double(m_A),1./3.)/rpa->hBar_c();
    m_d = 0.5;
  }
  m_rho0  = CalculateDensity();
  msg_Out()<<"Init Wood-Saxon for "<<m_beam<<": "
	   <<"Z = "<<m_Z<<", A = "<<m_A<<", "
	   <<"R = "<<(1000.*m_R)<<" 1/MeV = "<<(m_R*rpa->hBar_c())<<" fm,\n"
	   <<"   rho_0 = "<<(double(m_A)*m_rho0)<<" GeV^3 = "
	   <<(double(m_A)*m_rho0/pow(rpa->hBar_c(),3))<<" fm^-3\n";
  InitFFTable(0.,1.);
}

void EPA_WoodSaxon::InitFFTable(const double & q2min,const double & q2max) {
  p_FF_Q2 = new OneDim_Table(axis(100000,q2min,q2max,axis_mode::linear));
  WS_argument * ws = new WS_argument(m_R,m_d);
  Gauss_Integrator gauss(ws);
  for (size_t i=0;i<p_FF_Q2->GetAxis().m_nbins;i++) {
    ws->SetQ(sqrt(p_FF_Q2->GetAxis().x(i)));
    double rmin = 0., rmax = m_R;
    double res  = m_rho0*gauss.Integrate(rmin,rmax,1.e-6,0), inc = 0.;
    do {
      rmin = rmax; rmax *= 2.;
      res += inc  = m_rho0*gauss.Integrate(rmin,rmax,1.e-6,0);
    } while (dabs(inc/res)>1.e-6);
    p_FF_Q2->Fill(i,res);
  }
}

double EPA_WoodSaxon::CalculateDensity() {
  Rho_argument * rho = new Rho_argument(m_R,m_d);
  Gauss_Integrator gauss(rho);
  double rmin = 0., rmax = m_R;
  double res  = gauss.Integrate(rmin,rmax,1.e-3), inc = 0.;
  do {
    rmin = rmax; rmax *= 2.;
    res += inc  = gauss.Integrate(rmin,rmax,1.e-6);
  } while (inc>1.e-6*res);
  return 1./res;
}

const double EPA_WoodSaxon::operator()(const double & x,const double & Q2) {
  return 0.;
}

const double EPA_WoodSaxon::N(const double & x) {
  return 0.;
}



/*
  else if (m_beam.Kfcode() == kf_p_plus) {
    const double qz = 0.71;
    double f, qmi, qma;
    qma = m_q2max / qz;
    // x = omega/E = (E-E')/E  ; E,E' - incoming and outgoing protons energy
    //                           omega = E-E' - energy of emitted photon
    qmi = m_mass * m_mass * x * x / (1 - x) / qz;
    qmi += m_pt2min / (1 - x) / qz;
    m_weight = Max(0.,  m_pref * M_PI * (phi(x, qma) - phi(x, qmi)) * (1. - x) / x );
    return true;
  } else if (m_beam.IsIon()) { // n(x)
    const int atomicNumber = m_beam.GetAtomicNumber();
    const double radius = 1.2 / .197 * pow(atomicNumber, 1. / 3.);
    double f, omega0, gamma;
    gamma = m_energy / m_beam.Mass();
    // gamma = m_energy * atomicNumber / m_beam.Mass();
    //  energy is defined as sqrt[s_NN], N=nucleon
    //  but recalculated already in the Beam_Spectra_Handler
    omega0 = gamma / radius;
    //std::cout << "radius=" << radius << std::endl;
    //std::cout << "omega0=" << omega0 << std::endl;
    //std::cout << "gamma=" << gamma << std::endl;
    //f = 2 * alpha * m_charge * m_charge / M_PI / (m_x * omega0);
    //f *= phi(m_x, m_Q2);
    f = 2 * alpha * m_charge * m_charge / M_PI / m_x;
    // since CalculateWeight() is dn=N(x)*dx/x and not dn=N(omega)*domega/omega
    // f = 2 * alpha * m_charge * m_charge / M_PI / (m_x * m_energy);
    f *= phi(m_x * m_energy / omega0, m_Q2); // phi(x_omega, m_Q2)
    // x_omega=m_x*m_energy/omega0

    m_weight = f;
    return true;
  }
  return false;
}
*/

double EPA::phi(double x, double qq) const {
  if (m_beam.Kfcode() == kf_p_plus) {
    const double a = 7.16;
    const double b = -3.96;
    const double c = .028;
    double y, qq1, f;
    qq1 = 1 + qq;
    y = x * x / (1 - x);
    f = (1 + a * y) * (-log(qq1 / qq) + 1 / qq1 + 1 / (2 * qq1 * qq1) +
                       1 / (3 * qq1 * qq1 * qq1));
    f += (1 - b) * y / (4 * qq * qq1 * qq1 * qq1);
    f += c * (1 + y / 4) *
         (log((qq1 - b) / qq1) + b / qq1 + b * b / (2 * qq1 * qq1) +
          b * b * b / (3 * qq1 * qq1 * qq1));
    return f;
  }
  if (m_beam.IsIon()) {
    // x := omega / omega0 is assumed in the following code!
    // ensure whether calls of phi for ions are done correctly
    // x_omega=x*E/omega0=x*E*R/gamma
    double f = 0.;
    // needed for gaussian shaped nucleus
    const double q0 = 0.06;
    const int atomicNumber = m_beam.GetAtomicNumber();
    const double radius = 1.2 / .197 * pow(atomicNumber, 1. / 3.);
    //CosInt Ci;
    // do form factor dependent calculation
    switch (m_type) {
    case EPA_ff_type::point:
      f = log(1. + (1. / (x * x))) / 2. + 1. / (1. + (1. / (x * x))) / 2. -
          1. / 2.;
      break;
    case EPA_ff_type::Gauss: 
      f = (1. + x * x / (q0 * q0 * radius * radius));
      f *= ExpIntegral(1, x * x / (q0 * q0 * radius * radius));
      f -= exp(-x * x / (q0 * q0 * radius * radius));
      f /= 2.;
      break;
    case EPA_ff_type::hcs:
      f += 3. / (16. * pow(x, 6.));
      f += 3. / (8. * pow(x, 4.));
      f -= cos(2. * x) * 3. / (16 * pow(x, 6.)) +
           cos(2. * x) * 7. / (40. * x * x);
      f -= cos(2. * x) * 1. / 20.;
      f -= sin(2. * x) * 3. / (8 * pow(x, 5.)) +
           sin(2. * x) * 1. / (10. * x * x * x);
      f += sin(2. * x) * 9. / (20. * x) - sin(2. * x) * x / 10.;
      //f -= Ci.GetCosInt(2. * x) * (1. + pow(x, 5.) / 5.); // integral-cosine
      break;
    case EPA_ff_type::smooth_hcs:
      if (x < 0.003) { // make n(x) smooth at low x
        f = 1.83698 * pow(x, -0.00652101) * M_PI * m_energy;
        // f=1.36549*pow(x,-0.059967)*M_PI*m_energy*atomicNumber;
        //  prefactor*c*x^a with c and a from a fit to x_omega*n(x_omega)
        f /= (2 * m_aqed * m_charge * m_charge * radius * m_beam.Mass());
      } else if (x > 1.33086) { // cut off oscillating parts at high x
        f = 0.;
      } else { // normal homogenously charged sphere
        f += 3. / (16. * pow(x, 6.));
        f += 3. / (8. * pow(x, 4.));
        f -= cos(2. * x) * 3. / (16 * pow(x, 6.)) +
             cos(2. * x) * 7. / (40. * x * x);
        f -= cos(2. * x) * 1. / 20.;
        f -= sin(2. * x) * 3. / (8 * pow(x, 5.)) +
             sin(2. * x) * 1. / (10. * x * x * x);
        f += sin(2. * x) * 9. / (20. * x) - sin(2. * x) * x / 10.;
        //f -= Ci.GetCosInt(2. * x) * (1. + pow(x, 5.) / 5.); // integral-cosine
      }
      break;
    default:
      THROW(fatal_error, "Unknown ion form factor chosen");
    }
    return f;
  }
  return 0.;
}


void EPA::Initialise() {
  Settings &s = Settings::GetMainSettings();
  RegisterDefaults();
  m_aqed      = s["EPA"]["AlphaQED"].Get<double>();
  m_pref      = sqr(m_charge)*m_aqed/M_PI;
  m_approx    = s["EPA"]["Approximation"].Get<size_t>();  
  m_analytic  = s["EPA"]["AnalyticFF"].Get<bool>();  
  m_q2max     = ExtractParameter(s,"Q2Max");
  m_q2min     = ExtractParameter(s,"Q2Min");
  m_theta_max = ExtractParameter(s,"ThetaMax");
  m_pt2max    = sqr(m_energy*m_theta_max);
  m_pt2min    = ExtractParameter(s,"PT2Min");
  m_xmin      = ExtractParameter(s,"xMin");
  m_xmax      = ExtractParameter(s,"xMax");
  m_bmin      = ExtractParameter(s,"bMin"); 
  m_bmax      = ExtractParameter(s,"bMax"); 
  m_nxbins    = s["EPA"]["xBins"].Get<int>();
  m_nbbins    = s["EPA"]["bBins"].Get<int>();

  p_ff = new EPA_WoodSaxon(Flavour(kf_lead208),2360.);
  WriteFiles();
  InitFormFactor(s);
  InitTables();
  WriteDebugFiles(s);

}

void EPA::RegisterDefaults() const {
  Settings &s = Settings::GetMainSettings();
  s["EPA"]["Q2Max"].SetDefault(3.0);
  s["EPA"]["Q2Min"].SetDefault(-1.);
  s["EPA"]["xMax"].SetDefault(1.);
  s["EPA"]["xMin"].SetDefault(0.);
  s["EPA"]["xBins"].SetDefault(200);
  // impact parameters in fm.  need to make this more elegant 
  s["EPA"]["bMin"].SetDefault(1.e-3);
  s["EPA"]["bMax"].SetDefault(1.e4);
  s["EPA"]["bBins"].SetDefault(100);
  s["EPA"]["PT2Min"].SetDefault(0.0);
  s["EPA"]["Form_Factor"].SetDefault(m_beam.FormFactor());
  s["EPA"]["AlphaQED"].SetDefault(0.0072992701);
  s["EPA"]["ThetaMax"].SetDefault(0.3);
  s["EPA"]["Approximation"].SetDefault(1);
  s["EPA"]["AnalyticFF"].SetDefault(true);
  s["EPA"]["Debug"].SetDefault(false);
  s["EPA"]["Debug_Files"].SetDefault("EPA_debugOutput");
}

double EPA::ExtractParameter(Settings &s,const std::string & tag) {
  std::vector<double> parms = s["EPA"][tag].GetVector<double>();
  if (parms.size()!=1 && parms.size()!=2)
    THROW(fatal_error, "Specify either one or two values for 'EPA:"+tag+"'.  Will exit.");
  double parm = (m_dir > 0) ? parms.front() : parms.back(); 
  if (tag=="PTMin" && parm>1.0) {
    /* pt2min > 1 - according to approximation of
       'qmi' calculation in CalculateWeight */
    THROW(critical_error, "Too big p_T cut 'EPA:"+tag+"'.  Will exit.");
  }
  return parm;
}

void EPA::InitFormFactor(Settings &s) {
  std::vector<int> formfactors = s["EPA"]["Form_Factor"].GetVector<int>();
  if (formfactors.size()!=1 && formfactors.size()!=2)
    THROW(fatal_error,
          "Specify either one or two values for `EPA:Form_Factor'.");
  int formfactor = (m_dir > 0) ? formfactors.front() : formfactors.back();
  switch (formfactor) {
  case  0: 
    m_type     = EPA_ff_type::point;
    m_analytic = true;
    p_ff       = new EPA_Point(m_beam,m_energy);
    break;
  case  1:
    m_type     = EPA_ff_type::Gauss;
    p_ff       = new EPA_Gauss(m_beam,m_energy);
    break;
  case  2:
    m_type     = EPA_ff_type::dipole;
    p_ff       = new EPA_Dipole(m_beam,m_energy);
    break;
  case 11:
    m_type     = EPA_ff_type::hcs;
    THROW(fatal_error,
          "Form factor not yet implemented "+ToString(int(m_type)));
    break;
  case 12:
    m_type     = EPA_ff_type::smooth_hcs;
    THROW(fatal_error,
          "Form factor not yet implemented "+ToString(int(m_type)));
    break;
  case 13:
    m_type     = EPA_ff_type::WoodSaxon;
    THROW(fatal_error,
          "Form factor not yet implemented "+ToString(int(m_type)));
    break;
  default:
    THROW(fatal_error,
          "unspecified EPA form factor: "+ToString(formfactor));
  }
}

void EPA::WriteDebugFiles(Settings &s) {
  if (s["EPA"]["Debug"].Get<bool>()) {
    std::vector<std::string> files{
      s["EPA"]["Debug_Files"].GetVector<std::string>()};
    if (files.size() != 1 && files.size() != 2)
      THROW(fatal_error,
            "Specify either one or two values for `EPA:Debug_Files'.");
    std::string filename{(m_dir > 0) ? files.front() : files.back()};
    std::string num(m_dir > 0 ? "1" : "2");
    filename += num + ".log";
    this->selfTest(filename);
  }
}

void EPA::selfTest(const std::string& filename) {
  std::ofstream debugOutput;
  debugOutput.open(filename.c_str());

  debugOutput << "# EPA::selfTest() starting ..." << std::endl;

  // select output format
  debugOutput.setf(std::ios::scientific, std::ios::floatfield);
  debugOutput.precision(10);

  double x_omega = .1e-2;
  const int atomicNumber = m_beam.GetAtomicNumber();
  const double radius = 1.2 / .197 * pow(atomicNumber, 1. / 3.);
  double omega0, gamma;
  gamma = m_energy / m_beam.Mass();
  // gamma = m_energy * atomicNumber / m_beam.Mass();
  //  energy is defined as sqrt[s_NN], N=nucleon
  //  but recalculated already in the Beam_Spectra_Handler
  omega0 = gamma / radius;

  // write parameters
  debugOutput << "# Form Factor: " << int(m_type) << std::endl;
  debugOutput << "# A= " << atomicNumber << std::endl;
  debugOutput << "# R= " << radius << std::endl;
  debugOutput << "# E= " << m_energy << std::endl;
  debugOutput << "# Z= " << m_charge << std::endl;
  debugOutput << "# M_Ion=" << m_beam.Mass() << std::endl;
  debugOutput << "# gamma= " << gamma << std::endl;
  debugOutput << "# omega0= " << omega0 << std::endl;

  // write spectrum
  while (x_omega < 5) {
    x_omega *= 1.005;
    CalculateWeight(x_omega * omega0 / m_energy, 0); // m_weight = n(x)
    debugOutput << x_omega << "\t" << x_omega * m_weight / m_energy
                << std::endl;
  }

  debugOutput << "# EPA::selfTest() finished" << std::endl << std::endl;
  debugOutput.close();
  return;
}

void EPA::InitdN_by_dx() {
  double xmin = Max(m_xmin, 1.e-6), xmax = Min(m_xmax,1.-1.e-12);
  p_N_x       = new OneDim_Table(axis(m_nxbins,  xmin,  xmax,axis_mode::log));
  KperpIntegrand   ktint(p_ff);
  Gauss_Integrator gauss(&ktint);
  msg_Out()<<METHOD<<"(x in ["<<xmin<<", "<<xmax<<"], "
	   <<"type = "<<int(m_type)<<" for "<<m_beam<<").\n";
  axis xaxis  = p_N_x->GetAxis();
  for (size_t i=0;i<xaxis.m_nbins;i++) {
    double x = xaxis.x(i);
    ktint.SetX(x);
    double q2min    = sqr(m_mass*x)/(1.-x), Q2min = q2min+sqr(m_mass*x);
    double q2max    = m_q2max,              Q2max = q2max+sqr(m_mass*x);
    // Integrate with Gauss-Chebyshev due to log structure of integrand
    double integral = gauss.Integrate(q2min,q2max,1.e-3,2);
    double n_x      = m_pref/x * integral;
    double check    = ( M_PI * m_pref/x *
			( log(Q2max/Q2min) -
			  sqr(m_mass*x)*(1./Q2min-1./Q2max) ) );
    double check2   = (*this)(x);
    //( M_PI * pref/x *
    //			((1.+sqr(1.-x))/2. * log(q2max/q2min)-
    //			 sqr(x*m_mass)*(1./q2min-1./q2max)) );
    msg_Out()<<"   n(x = "<<x<<", q^2 in ["<<q2min<<", "<<q2max<<"]) = "
	     <<n_x<<" (reduced = "<<integral<<") vs. "<<check<<", "
	     <<"ratio = "<<(n_x/check)<<", ratio2 = "<<(check2/check)<<"\n";
  }
  exit(1);
}

void EPA::InitTables() {
  InitdN_by_dx();
  double xmin = Max(m_xmin, 1.e-6), xmax = Min(m_xmax,1.);
  msg_Out()<<METHOD<<"(x in ["<<xmin<<", "<<xmax<<"], "
	   <<"b in ["<<m_bmin<<", "<<m_bmax<<"], "
	   <<"type = "<<ToString(int(m_type))<<" for "<<m_beam<<").\n";
  p_N_xb   = new TwoDim_Table(axis(m_nxbins,  xmin,  xmax,axis_mode::log),
			      axis(m_nbbins,m_bmin,m_bmax,axis_mode::log));
  //EPA_FF_Base * ff = new EPA_Gauss(m_beam,m_energy);
  EPA_FF_Base * ff = new EPA_Point(m_beam,m_energy);
  KperpIntegrand ktint(ff);
  ktint.SetMass(m_mass=Flavour(kf_p_plus).Mass());
  ktint.SetMode(1);
  Bessel_Integrator bessel(&ktint,1);
  axis xaxis = p_N_xb->GetAxis(0), yaxis = p_N_xb->GetAxis(1);
  for (size_t i=0;i<xaxis.m_nbins;i++) {
    double x = xaxis.x(i);
    ktint.SetX(x);
    for (size_t j=0;j<yaxis.m_nbins;j++) {
      double bT       = yaxis.x(j); 
      ktint.SetBT(bT);
      double ktmin    = 0.;
      double integral = bessel(ktmin/bT);
      if (integral<1.e-8) integral = 0.;
      double n_xb     = m_pref/x * sqr(integral);
      p_N_xb->Fill(i,j,n_xb);
      msg_Out()<<"   - 1/(xm) K("<<std::setw(12)<<std::setprecision(6)<<bT<<"*"
	       <<std::setw(12)<<std::setprecision(6)<<(x*m_mass)<<") = 1/(xm) * "
	       <<"K("<<std::setw(12)<<std::setprecision(6)<<(x*m_mass*bT)<<") = "
	       <<std::setw(12)<<std::setprecision(6)<<(integral/(x*m_mass))<<" vs. "
	       <<std::setw(12)<<std::setprecision(6)<<SF.Kn(1,x*m_mass*bT)<<", "
	       <<"ratio = "<<std::setw(12)<<std::setprecision(6)
	       <<(integral/(x*m_mass*SF.Kn(1,x*m_mass*bT)))<<".\n";
    }
  }
  BIntegrand bint(p_N_xb);
  Gauss_Integrator gaussB(&bint);
  for (size_t i=0;i<xaxis.m_nbins;i++) {
    double x     = xaxis.x(i), x2 = x*x; 
    double vol   = M_PI*(sqr(m_bmax)-sqr(m_bmin));
    double q2min = sqr(m_mass * x) / (1. - x);
    double q2max = m_q2max;
    double check = (2.*M_PI*m_pref/x *
		    ((1.+sqr(1.-x)*log(q2max/q2min))-
		     2.*sqr(x*m_mass)*(1./q2min-1./q2max))/4.);
    /*
    switch (m_type) {
    case EPA_ff_type::Gauss:
      break;
    case EPA_ff_type::dipole:
      check = (*this)(x);
      break;
    case EPA_ff_type::point:
    default:
      break;
    }
    */
    bint.SetX(x);
    double GeV_fm = rpa->hBar()*rpa->c()*1.e12;
    double bmin   = sqrt(1./q2max);  //(x*m_mass*m_beam.Radius()/GeV_fm); 
    double bmax   = sqrt(1./q2min); //sqrt(sqr(x*m_mass*m_beam.Radius()/GeV_fm)+1.); 
    double n_x    = gaussB.Integrate(bmin,bmax,1.e-3);
    msg_Out()<<METHOD<<"(x = "<<xaxis.x(i)<<", R = "<<m_beam.Radius()<<", "
	     <<i<<" of "<<xaxis.m_nbins<<"): "
	     <<"n(x) = "<<n_x<<" vs. form("<<int(m_type)<<") = "<<check<<", "
	     <<"ratio = "<<(n_x/check)<<".\n";    
  }
  exit(1);
}

double KperpIntegrand::operator()(double xk) {
  switch (m_mode) {
  case 1: {
    // This is the mode used for the integration
    // dk_T^2 k_T^2 F[k_T^2+(x m)^2]/[k_T^2+(x m)^2] J_1(b_T k_T)
    // with xk = b_T * k_T  dk_T = dxk/b_T
    double kT = xk/m_bT, kT2 = sqr(kT), kT2tilde = kT2+sqr(m_x*m_mass);
    return 1./m_bT * kT2/kT2tilde * (*p_ff)(kT2tilde);
  }
  case 0:
  default:
    break;
  }
  // This is the mode used for the integration
  // d^2k_T k_T^2 { F[k_T^2+(x m)^2]/[k_T^2+(x m)^2] }^2 =
  // pi dk_T^2 k_T^2 { F[k_T^2+(x m)^2]/[k_T^2+(x m)^2] }^2 =
  // with xk = k_T^2
  double kT2 = xk, kT2tilde = kT2+sqr(m_x*m_mass);
  return M_PI * kT2 * sqr((*p_ff)(kT2tilde)/kT2tilde);
}

void EPA::TestIntegration() {
  msg_Out()<<METHOD<<" checks for Bessel functions:\n";
  for (size_t i=0;i<21;i++) {
    double x = i<10 ? double(i)/10. : pow(10.,(i-10)/2.);
    msg_Out()<<"   BesselK_1("<<x<<") = "
	     <<std::cyl_bessel_k(1.,x)<<" & "
	     <<"BesselJ_1("<<x<<") = "<<SF.Jn(1.,x)<<" & "
	     <<"BesselK_1("<<x<<") = "<<SF.Kn(1.,x)<<"\n";
  }
  msg_Out()<<METHOD<<" checks for point form factor:\n";
  EPA_FF_Base * ff = new EPA_Point(m_beam,m_energy);
  for (size_t i=0;i<20;i++) {
    double Q2 = i<10 ? double(i)/10 : pow(double(i-9),4);
    msg_Out()<<"   FF("<<Q2<<") = "<<(*ff)(Q2)<<"\n";
  }
  KperpIntegrand ktint(ff);
  ktint.SetMass(m_beam.IsLepton() ? m_mass : Flavour(kf_p_plus).Mass(true));
  double ktmin = 0.;    //sqrt(q2min);
  double ktmax = 1.e6; //sqrt(q2max); 
  Gauss_Integrator gauss(&ktint);
  axis xaxis      = p_N_xb->GetAxis(0), yaxis = p_N_xb->GetAxis(1);
  for (size_t i=0;i<xaxis.m_nbins;i++) {
    for (size_t j=0;j<yaxis.m_nbins;j++) {
      double x = xaxis.x(i), bT = yaxis.x(j);
      ktint.SetX(x);
      ktint.SetBT(bT);
      double integral = 0.; //gauss.Integrate(ktmin,ktmax,1.e-3);
      for (size_t N=0;N<10000000;N++) {
	double kT = ran->Get()*(ktmax-ktmin);
	integral += ktint(kT)*(ktmax-ktmin);
      }
      integral /= 10000000;
      double n_xb     = m_pref/x * sqr(integral);
      double check    = m_pref/x * sqr(x*m_mass*SF.Kn(1,x*m_mass*bT));
      double naive    = m_pref/x * 1./sqr(bT);
      msg_Out()<<METHOD<<"(x = "<<xaxis.x(i)<<", b = "<<yaxis.x(j)<<"): "
	       <<"n(x,b) = "<<n_xb<<" vs. form("<<int(m_type)<<") = "<<check<<", "
	       <<"naive = "<<naive<<", ratio = "<<(naive/check)<<".\n";    
    }
  }
  exit(1);
}



/*
double EPA::CosInt::GetCosInt(double X) {
  if (X < 0.) THROW(fatal_error,"method called with negative X");
  ATOOLS::Gauss_Integrator integrator(this);
  return integrator.Integrate(X, 100000., 1.e-4, 1);
}

*/
