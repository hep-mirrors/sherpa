#include "BEAM/Spectra/EPA.H"
#include "BEAM/Spectra/EPA_FF.H"
#include "BEAM/Spectra/EPA_Spectra_Plotter.H"
#include "ATOOLS/Math/Special_Functions.H"
#include "ATOOLS/Math/MathTools.H"
#include "ATOOLS/Math/Bessel_Integrator.H"
#include "ATOOLS/Math/Gauss_Integrator.H"
#include "ATOOLS/Math/Random.H"
#include "ATOOLS/Org/Exception.H"
#include "ATOOLS/Org/Message.H"
#include "ATOOLS/Org/Run_Parameter.H"
#include "ATOOLS/Org/MyStrStream.H"
#include "ATOOLS/Org/My_File.H"
#include "ATOOLS/Org/Settings.H"

#include <fstream>
#include <string>

using namespace BEAM;
using namespace ATOOLS;
using namespace std;

EPA::EPA(const Flavour beam, const double energy,
	 const double pol, const int dir) :
  Beam_Base(beamspectrum::EPA, beam, energy, pol, dir),
  m_type(EPA_ff_type::point), p_ff(nullptr), 
  m_mass(m_beam.Mass(true)), m_charge(m_beam.Charge()),
  m_gamma(m_energy/m_mass), m_plotting(0)
{
  Initialise();
  m_Nbunches   = 2;
  m_bunches.resize(m_Nbunches);
  m_bunches[0] = Flavour(kf_photon);
  m_bunches[1] = m_beam;
  m_vecouts.resize(m_Nbunches);
  m_vecouts[0] = Vec4D(m_energy, 0., 0., m_dir * m_energy);
  m_vecouts[1] = Vec4D(0.,0.,0.,0.);
  m_on         = true;
  exit(1);
}

void EPA::FixPosition() {
  /*
  // This is a bit of a poor-man's choice for a point-like source,
  // with a minmimal distance m_minR ... we would need some notion of
  // off'shellness here ...
  double ratio = m_maxR/m_minR, logratio = log(ratio), R, phi;
  if (ran->Get()< logratio/(0.5+logratio)) {
    R = m_minR * pow(ratio,ran->Get());
  }
  else {
    R = m_minR * sqrt(ran->Get());
  }
  phi = 2.*M_PI*ran->Get();
  m_position = R * Vec4D(0., cos(phi), sin(phi), 0.);
  */
}

void EPA::SetOutMomentum(const ATOOLS::Vec4D &out, const size_t & i) {
  if (i==0) {
    m_vecouts[0] = out;
    m_vecouts[1] = m_lab-out;
  }
}


double EPA::phi(double x, double qq) const {
  if (m_beam.Kfcode() == kf_p_plus) {
    const double a = 7.16;
    const double b = -3.96;
    const double c = .028;
    double y, qq1, f;
    qq1 = 1 + qq;
    y = x * x / (1 - x);
    f = (1 + a * y) * (-log(qq1 / qq) + 1 / qq1 + 1 / (2 * qq1 * qq1) +
                       1 / (3 * qq1 * qq1 * qq1));
    f += (1 - b) * y / (4 * qq * qq1 * qq1 * qq1);
    f += c * (1 + y / 4) *
         (log((qq1 - b) / qq1) + b / qq1 + b * b / (2 * qq1 * qq1) +
          b * b * b / (3 * qq1 * qq1 * qq1));
    return f;
  }
  if (m_beam.IsIon()) {
    // x := omega / omega0 is assumed in the following code!
    // ensure whether calls of phi for ions are done correctly
    // x_omega=x*E/omega0=x*E*R/gamma
    double f = 0.;
    // needed for gaussian shaped nucleus
    const double q0 = 0.06;
    const int atomicNumber = m_beam.GetAtomicNumber();
    const double radius = 1.2 / .197 * pow(atomicNumber, 1. / 3.);
    //CosInt Ci;
    // do form factor dependent calculation
    switch (m_type) {
    case EPA_ff_type::point:
      f = log(1. + (1. / (x * x))) / 2. + 1. / (1. + (1. / (x * x))) / 2. -
          1. / 2.;
      break;
    case EPA_ff_type::Gauss: 
      f = (1. + x * x / (q0 * q0 * radius * radius));
      f *= ExpIntegral(1, x * x / (q0 * q0 * radius * radius));
      f -= exp(-x * x / (q0 * q0 * radius * radius));
      f /= 2.;
      break;
    case EPA_ff_type::hcs:
      f += 3. / (16. * pow(x, 6.));
      f += 3. / (8. * pow(x, 4.));
      f -= cos(2. * x) * 3. / (16 * pow(x, 6.)) +
           cos(2. * x) * 7. / (40. * x * x);
      f -= cos(2. * x) * 1. / 20.;
      f -= sin(2. * x) * 3. / (8 * pow(x, 5.)) +
           sin(2. * x) * 1. / (10. * x * x * x);
      f += sin(2. * x) * 9. / (20. * x) - sin(2. * x) * x / 10.;
      //f -= Ci.GetCosInt(2. * x) * (1. + pow(x, 5.) / 5.); // integral-cosine
      break;
    case EPA_ff_type::smooth_hcs:
      if (x < 0.003) { // make n(x) smooth at low x
        f = 1.83698 * pow(x, -0.00652101) * M_PI * m_energy;
        // f=1.36549*pow(x,-0.059967)*M_PI*m_energy*atomicNumber;
        //  prefactor*c*x^a with c and a from a fit to x_omega*n(x_omega)
        f /= (2 * m_aqed * m_charge * m_charge * radius * m_beam.Mass());
      } else if (x > 1.33086) { // cut off oscillating parts at high x
        f = 0.;
      } else { // normal homogenously charged sphere
        f += 3. / (16. * pow(x, 6.));
        f += 3. / (8. * pow(x, 4.));
        f -= cos(2. * x) * 3. / (16 * pow(x, 6.)) +
             cos(2. * x) * 7. / (40. * x * x);
        f -= cos(2. * x) * 1. / 20.;
        f -= sin(2. * x) * 3. / (8 * pow(x, 5.)) +
             sin(2. * x) * 1. / (10. * x * x * x);
        f += sin(2. * x) * 9. / (20. * x) - sin(2. * x) * x / 10.;
        //f -= Ci.GetCosInt(2. * x) * (1. + pow(x, 5.) / 5.); // integral-cosine
      }
      break;
    default:
      THROW(fatal_error, "Unknown ion form factor chosen");
    }
    return f;
  }
  return 0.;
}


void EPA::Initialise() {
  Settings &s = Settings::GetMainSettings();
  RegisterDefaults();
  m_aqed      = s["EPA"]["AlphaQED"].Get<double>();
  m_pref      = sqr(m_charge)*m_aqed/M_PI;
  m_approx    = s["EPA"]["Approximation"].Get<size_t>();  
  m_analytic  = s["EPA"]["AnalyticFF"].Get<bool>();  
  m_plotting  = s["EPA"]["PlotSpectra"].Get<bool>();  
  m_q2max     = ExtractParameter(s,"Q2Max");
  m_q2min     = ExtractParameter(s,"Q2Min");
  m_theta_max = ExtractParameter(s,"ThetaMax");
  m_pt2max    = sqr(m_energy*m_theta_max);
  m_pt2min    = ExtractParameter(s,"PT2Min");
  m_xmin      = ExtractParameter(s,"xMin");
  m_xmax      = ExtractParameter(s,"xMax");
  m_bmin      = ExtractParameter(s,"bMin"); 
  m_bmax      = ExtractParameter(s,"bMax"); 
  m_nxbins    = s["EPA"]["xBins"].Get<int>();
  m_nbbins    = s["EPA"]["bBins"].Get<int>();

  InitFormFactor(s);
  InitTables();
  //WriteDebugFiles(s);
  if (m_plotting>0) {
    EPA_Spectra_Plotter plotter(this,string("Spectra"));
    plotter(m_plotting);
  }
}

void EPA::RegisterDefaults() const {
  Settings &s = Settings::GetMainSettings();
  s["EPA"]["Q2Max"].SetDefault(3.0);
  s["EPA"]["Q2Min"].SetDefault(-1.);
  s["EPA"]["xMax"].SetDefault(1.);
  s["EPA"]["xMin"].SetDefault(0.);
  s["EPA"]["xBins"].SetDefault(200);
  // impact parameters in fm.  need to make this more elegant 
  s["EPA"]["bMin"].SetDefault(1.e-3);
  s["EPA"]["bMax"].SetDefault(1.e4);
  s["EPA"]["bBins"].SetDefault(100);
  s["EPA"]["PT2Min"].SetDefault(0.0);
  s["EPA"]["Form_Factor"].SetDefault(m_beam.FormFactor());
  s["EPA"]["AlphaQED"].SetDefault(0.0072992701);
  s["EPA"]["ThetaMax"].SetDefault(0.3);
  s["EPA"]["Approximation"].SetDefault(1);
  s["EPA"]["AnalyticFF"].SetDefault(true);
  s["EPA"]["PlotSpectra"].SetDefault(0);
  s["EPA"]["Debug"].SetDefault(false);
  s["EPA"]["Debug_Files"].SetDefault("EPA_debugOutput");
}

double EPA::ExtractParameter(Settings &s,const std::string & tag) {
  std::vector<double> parms = s["EPA"][tag].GetVector<double>();
  if (parms.size()!=1 && parms.size()!=2)
    THROW(fatal_error,
	  "Specify either one or two values for 'EPA:"+tag+"'.  Will exit.");
  double parm = (m_dir > 0) ? parms.front() : parms.back(); 
  if (tag=="PTMin" && parm>1.0) {
    /* pt2min > 1 - according to approximation of
       'qmi' calculation in CalculateWeight */
    THROW(critical_error, "Too big p_T cut 'EPA:"+tag+"'.  Will exit.");
  }
  return parm;
}

void EPA::InitFormFactor(Settings &s) {
  std::vector<int> formfactors = s["EPA"]["Form_Factor"].GetVector<int>();
  if (formfactors.size()!=1 && formfactors.size()!=2)
    THROW(fatal_error,
          "Specify either one or two values for `EPA:Form_Factor'.");
  int formfactor = (m_dir > 0) ? formfactors.front() : formfactors.back();
  switch (formfactor) {
  case  0: 
    m_type = EPA_ff_type::point;
    p_ff   = new EPA_Point(m_beam,m_energy);
    break;
  case  1:
    m_type = EPA_ff_type::Gauss;
    p_ff   = new EPA_Gauss(m_beam,m_energy);
    break;
  case  2:
    m_type = EPA_ff_type::dipole;
    p_ff   = new EPA_Dipole(m_beam,m_energy);
    break;
  case 13:
    m_type = EPA_ff_type::WoodSaxon;
    p_ff   = new EPA_WoodSaxon(m_beam,m_energy);
    break;
  default:
    THROW(fatal_error,
          "unspecified EPA form factor: "+ToString(formfactor));
  }
}

void EPA::WriteDebugFiles(Settings &s) {
  if (s["EPA"]["Debug"].Get<bool>()) {
    std::vector<std::string> files{
      s["EPA"]["Debug_Files"].GetVector<std::string>()};
    if (files.size() != 1 && files.size() != 2)
      THROW(fatal_error,
            "Specify either one or two values for `EPA:Debug_Files'.");
    std::string filename{(m_dir > 0) ? files.front() : files.back()};
    std::string num(m_dir > 0 ? "1" : "2");
    filename += num + ".log";
    this->selfTest(filename);
  }
}

void EPA::selfTest(const std::string& filename) {
  std::ofstream debugOutput;
  debugOutput.open(filename.c_str());

  debugOutput << "# EPA::selfTest() starting ..." << std::endl;

  // select output format
  debugOutput.setf(std::ios::scientific, std::ios::floatfield);
  debugOutput.precision(10);

  double x_omega = .1e-2;
  const int atomicNumber = m_beam.GetAtomicNumber();
  const double radius = 1.2 / .197 * pow(atomicNumber, 1. / 3.);
  double omega0, gamma;
  gamma = m_energy / m_beam.Mass();
  // gamma = m_energy * atomicNumber / m_beam.Mass();
  //  energy is defined as sqrt[s_NN], N=nucleon
  //  but recalculated already in the Beam_Spectra_Handler
  omega0 = gamma / radius;

  // write parameters
  debugOutput << "# Form Factor: " << int(m_type) << std::endl;
  debugOutput << "# A= " << atomicNumber << std::endl;
  debugOutput << "# R= " << radius << std::endl;
  debugOutput << "# E= " << m_energy << std::endl;
  debugOutput << "# Z= " << m_charge << std::endl;
  debugOutput << "# M_Ion=" << m_beam.Mass() << std::endl;
  debugOutput << "# gamma= " << gamma << std::endl;
  debugOutput << "# omega0= " << omega0 << std::endl;

  // write spectrum
  while (x_omega < 5) {
    x_omega *= 1.005;
    CalculateWeight(x_omega * omega0 / m_energy, 0); // m_weight = n(x)
    debugOutput << x_omega << "\t" << x_omega * m_weight / m_energy
                << std::endl;
  }

  debugOutput << "# EPA::selfTest() finished" << std::endl << std::endl;
  debugOutput.close();
  return;
}



/*
double EPA::CosInt::GetCosInt(double X) {
  if (X < 0.) THROW(fatal_error,"method called with negative X");
  ATOOLS::Gauss_Integrator integrator(this);
  return integrator.Integrate(X, 100000., 1.e-4, 1);
}

*/
