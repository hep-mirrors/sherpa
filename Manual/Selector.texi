@node Selectors
@section Selectors
@cindex SHOW_SELECTOR_SYNTAX

Sherpa provides the following selectors that set up cuts at the matrix element
level:

@menu
* Inclusive selectors::       inclusive particle selectors
* One particle selectors::    one particle selectors
* Two particle selectors::    two particle selectors
* Decay selectors::           decay selectors
* Particle dressers::         charged particle photon recombinations
* Jet selectors::             jet algorithms
* Universal selector::        user-defined cuts
* Minimum selector::          cuts that are inclusive for several selectors
@end menu

Some selectors modify the momenta and flavours of the set of 
final state particles. These selectors also take a list of 
subselectors which then act on the modified flavours and momenta. 
Details are explained in the respective selectors' description.

@node Inclusive selectors
@subsection Inclusive selectors

The selectors listed here implement cuts on the
matrix element level, based on event properties.
The corresponding syntax is
@verbatim
SELECTORS:
- [<keyword>, <parameter 1>, <parameter 2>, ...]
- # other selectors ...
@end verbatim

Parameters that accept numbers can also be given in a form that is understood
by the internal algebra interpreter, see @ref{Interpreter}.
The selectors act on @emph{all} particles in the event. 
Their respective keywords are

@table @option
@item [N, <kf>, <min value>, <max value>]
Minimum and maximum multiplicity of flavour @code{<kf>} in the 
final state.
@item [PTmis, <min value>, <max value>]
Missing transverse momentum cut (at the moment only neutrinos are 
considered invisible)
@item [ETmis, <min value>, <max value>]
Missing transverse energy cut (at the moment only neutrinos are 
considered invisible)
@item [IsolationCut, <kf>, <dR>, <exponent>, <epsilon>, <optional: mass_max>]
Smooth cone isolation @mycite{Frixione1998jh}, the parameters given 
are the flavour @code{<kf>} to be isolated against massless partons 
and the isolation cone parameters.
@item [NJ, <N>, <algo>, <min value>, <max value>]
NJettiness from @mycite{Stewart2010tn}, where @code{<algo>} specifies 
the jet finding algorithm to determine the hard jet directions and 
@code{<N>} is their multiplicity. 
@code{algo=kt|antikt|cambridge|siscone,PT:<ptmin>,R:<dR>[,[ETA:<etamax>,Y:<ymax>]]}
@end table

@node One particle selectors
@subsection One particle selectors

The selectors listed here implement cuts on the
matrix element level, based on single particle kinematics.
The corresponding  syntax is
@verbatim
SELECTORS:
- [<keyword>, <flavour code>, <min value>, <max value>]
- # other selectors ...
@end verbatim

@option{<min value>} and @option{<max value>} are floating point
numbers, which can also be given in a form that is understood
by the internal algebra interpreter, see @ref{Interpreter}.
The selectors act on @emph{all} possible particles with 
the given flavour. Their respective keywords are

@table @option
@item PT
transverse momentum cut
@item ET
transverse energy cut
@item Y
rapidity cut
@item Eta
pseudorapidity cut
@item PZIN
cut on the z-component of the momentum, acts on initial-state flavours only
(commonly used in DIS analyses)
@end table


@node Two particle selectors
@subsection Two particle selectors

The selectors listed here implement cuts on the
matrix element level, based on two particle kinematics.
The corresponding is
@verbatim
SELECTORS:
- [<keyword>, <flavour1 code>, <flavour2 code>, <min value>, <max value>]
- # other selectors ...
@end verbatim

@option{<min value>} and @option{<max value>} are floating point
numbers, which can also be given in a form that is understood
by the internal algebra interpreter, see @ref{Interpreter}.
The selectors act on @emph{all} possible particles with 
the given flavour. Their respective keywords are

@table @option
@item Mass
invariant mass
@item Q2
DIS-like virtuality
@item PT2
pair transverse momentum
@item MT2
pair transverse mass
@item DY
rapidity separation
@item DEta
pseudorapidity separation
@item DPhi
azimuthal separation
@item DR
angular separation (build from eta and phi)
@item DR(y)
angular separation (build from y and phi)
@item INEL
inelasticity, one of the flavours must be in the initial-state (commonly used
in DIS analyses)
@end table


@node Decay selectors
@subsection Decay selectors

The selectors listed here implement cuts on the matrix element level, 
based on particle decays, see @ref{Decay} and @ref{DecayOS}.
 
@table @option
@item DecayMass
Invariant mass of a decaying particle. The syntax is
@verbatim - [DecayMass, <flavour code>, <min value>, <max value>]
@end verbatim
@item Decay
Any kinematic variable of a decaying particle. The syntax is
@verbatim - [Decay(<expression>), <flavour code>, <min value>, <max value>]
@end verbatim
where @code{<expression>} is an expression handled by the
internal interpreter, see @ref{Interpreter}. 
@item Decay2
Any kinematic variable of a pair of decaying particles. The syntax is
@verbatim - [Decay2(<expression>), <flavour1 code>, <flavour2 code>, <min value>, <max value>]
@end verbatim
where @code{<expression>} is an expression handled by the
internal interpreter, see @ref{Interpreter}. 
@end table
Particles are identified by flavour, i.e. the cut is applied 
on @emph{all} decaying particles that match @option{<flavour code>}.
@option{<min value>} and @option{<max value>} are floating point
numbers, which can also be given in a format that is understood
by the internal algebra interpreter, see @ref{Interpreter}.


@node Particle dressers
@subsection Particle dressers

@node Jet selectors
@subsection Jet selectors

There are two different types of jet finders

@table @option
@item NJetFinder
k_T-type algorithm to select on a given number of jets
@item FastjetFinder
Select on a given number of jets using FastJet algorithms
@end table

Their respective syntax and defaults are
@verbatim
SELECTORS:
- Type: NJetFinder
  N: 0
  PTMin: 0
  ETMin: 0
  R: 0.4
  Exp: 1
  EtaMax: None
  YMax: None
  MassMax: None
- Type: FastjetFinder
  Algorithm: kt
  N: 0
  PTMin: 0.0
  ETMin: 0.0
  DR: 0.4
  f: 0.75        # Siscone f parameter
  EtaMax: 100
  YMax: 100
  Nb: -1
  Nb2: -1

@end verbatim

Note that all parameters except for @code{Type} are optional. If they are not
specified, their respective default value is used.

The @option{NJetFinder} allows to select for kinematic configurations with
at least @option{<N>} jets that satisfy both, the @option{<PTMin>} and the
@option{<ETMin>} minimum requirements and that are in a PseudoRapidity region
|eta|<@option{<EtaMax>}. The @option{<Exp>} (exponent) allows to apply a
kt-algorithm
(1) or an anti-kt algorithm (-1). As only massless partons are clustered by 
default, the @option{<MassMax>} allows to also include partons with a mass
up to the specified values. This is useful e.g. in calculations with massive 
b-quarks which shall nonetheless satisfy jet criteria.

The second option @option{FastjetFinder} allows to use the
@uref{http://www.fastjet.fr,,FastJet} plugin if enabled during configuration(*).
It takes the following arguments: @code{<Algorithm>} can take the values
@code{kt,antikt,cambridge,siscone,eecambridge,jade}, @code{<N>} is the minimum
number of jets to be found, @code{<PTMin>} and @code{<ETMin>} are the minimum
transverse momentum and/or energy, @code{<DR>} is the radial parameter.
Optional arguments are: @code{<f>} (default 0.75, only relevant for the Siscone
algorithm), @code{<EtaMax>} and @code{<YMax>} as maximal absolute
(pseudo-)rapidity, @code{<Nb>} and @code{<Nb2>} set the number of required
b-jets, where for the
former both b and anti-b quarks are counted equally towards b-jets, while for
the latter they are added with a relative sign as constituents, i.e. a jet
containing b and anti-b is not tagged (default: -1, i.e. no b jets are
required).
Note that only @code{<Algorithm>}, @code{<N>} and @code{<PTMin>} are relevant
for the lepton-lepton collider algorithms.

The selector @option{FastjetVeto} allows to use the
@uref{http://www.fastjet.fr,,FastJet} plugin to apply
jet veto cuts. The syntax is identical to option @option{FastjetFinder}.

If @uref{http://www.fastjet.fr,,FastJet} is enabled, the momenta and nodal 
values of the jets found with Fastjet can be used to calculate more elaborate 
selector criteria. The syntax of this selector is

@verbatim
- Type: FastjetSelector
  Expression: <expression>
  Algorithm: kt
  N: 0
  PTMin: 0
  ETMin: 0
  DR: 0.4
  f: 0.75
  EtaMax: 100
  YMax: 100
  BMode: 0
@end verbatim

wherein @code{algorithm} can take the values
@code{kt,antikt,cambridge,siscone,eecambridge,jade}.
In the algebraic @code{expression} @code{MU_n2} (n=2..njet+1) signify the nodal 
values of the jets found and @code{p[i]} are their momenta. For details see
@ref{Scale setters}. For example, in lepton pair production in 
association with jets

@verbatim
- Type: FastjetSelector
  Expression: Mass(p[4]+p[5])>100
  Algorithm: antikt
  N: 2
  PTMin: 40
  ETMin: 0
  DR: 0.5
@end verbatim

selects all phase space points where two anti-kt jets with at least 40 GeV of
transverse momentum and an invariant mass of at least 100 GeV are found. The 
expression must calculate a boolean value.
The @code{BMode} parameter, if specified different from its default 0, allows
to use b-tagged jets only, based on the parton-level constituents of the jets.
There are two options: With @code{BMode: 1} both b and anti-b quarks are
counted equally towards b-jets, while for @code{BMode: 2} they are added with a
relative sign as constituents, i.e. a jet containing b and anti-b is not tagged.
Note that only @code{<epression>}, @code{<algorithm>}, @code{<n>} and
@code{<ptmin>} are relevant when using the lepton-lepton collider algorithms.

@node Universal selector
@subsection Universal selector
@cindex SHOW_VARIABLE_SYNTAX

The universal selector is intended to implement non-standard cuts
on the matrix element level. Its syntax is
@verbatim
SELECTORS:
- Type: VariableSelector
  Variable: <variable>
  Flavs: [<kf1>, ..., <kfn>]
  Ranges:
  - [<min1>, <max1>]
  - ...
  - [<minn>, <maxn>]
  Ordering: "[<order1>,...,<orderm>]"
@end verbatim

The @code{Variable} parameter defines the name
of the variable to cut on. The keywords for available predefined
can be figured by running Sherpa @option{SHOW_VARIABLE_SYNTAX: true}.
Or alternatively, an arbitrary cut variable can be constructed using
the internal interpreter, see @ref{Interpreter}. This is invoked
with the command @samp{Calc(...)}. In the formula specified there
you have to use place holders for the momenta of the particles: 
@samp{p[0]} ... @samp{p[n]} hold the momenta of the respective particles 
@samp{kf1} ... @samp{kfn}. A list of available vector functions and
operators can be found here @ref{Interpreter}.

@option{<kf1>,..,<kfn>} specify the PDG codes of the particles the variable has
to be calculated from.  The ranges @option{[<min>, <max>]} then define the cut
regions.

If the @code{Ordering} parameter is not given, the order of cuts is determined
internally, according to Sherpa's process classification scheme.
This then has to be matched if you want to have different cuts
on certain different particles in the matrix element. To do this,
you should put enough (for the possible number of combinations 
of your particles) arbitrary ranges at first and run Sherpa 
with debugging output for the universal selector:
@samp{Sherpa 'FUNCTION_OUTPUT: @{"Variable_Selector::Trigger": 15@}'}.
This will start to produce lots of output during integration,
at which point you can interrupt the run (Ctrl-c). In the
@samp{Variable_Selector::Trigger(): @{...@}} output you can see,
which particle combinations have been found and which cut range
your selector has held for them (vs. the arbitrary range you
specified). From that you should get an idea, in which order
the cuts have to be specified.

If the fourth argument is given, particles are ordered
before the cut is applied. Possible orderings are @option{PT_UP},
@option{ET_UP}, @option{E_UP}, @option{ETA_UP} and @option{ETA_DOWN},
(increasing p_T, E_T, E, eta, and decreasing eta). They have to be specified
for each of the particles, separated by commas.


Examples

@verbatim
SELECTORS:
# two-body transverse mass
- Type: VariableSelector
  Variable: mT
  Flavs: [11, -12]
  Ranges:
  - [50, E_CMS]

# cut on the pT of only the hardest lepton in the event
- Type: VariableSelector
  Variable: PT
  Flavs: 90
  Ranges:
  - [50, E_CMS]
  Ordering: "[PT_UP]"

# using bool operations to restrict eta of the electron to |eta| < 1.1 or
# 1.5 < |eta| < 2.5
- Type: VariableSelector
  Variable: Calc(abs(Eta(p[0]))<1.1||(abs(Eta(p[0]))>1.5&&abs(Eta(p[0]))<2.5))
  Flavs: 11
  Ranges:
  - [1, 1]  # NOTE: this means true for bool operations

# requesting opposite side tag jets in VBF
- Type: VariableSelector
  Variable: Calc(Eta(p[0])*Eta(p[1]))
  Flavs: [93, 93]
  Ranges:
  - [-100, 0]
  Ordering: "[PT_UP,PT_UP]"

# restricting electron+photon mass to be outside of [87.0,97.0]
- Type: VariableSelector
  Variable: Calc(Mass(p[0]+p[1])<87.0||Mass(p[0]+p[1])>97.0)
  Flavs: [11, 22]
  Ranges:
  - [1, 1]

# in @samp{Z[lepton lepton] Z[lepton lepton]}, cut on mass of lepton-pairs
# produced from Z's
- Type: VariableSelector
  Variable: m
  Flavs: [90, 90]
  # here we use knowledge about the internal ordering to cut only on the
  # correct lepton pairs
  Ranges:
  - [80, 100]
  - [0, E_CMS]
  - [0, E_CMS]
  - [0, E_CMS]
  - [0, E_CMS]
  - [80, 100]
@end verbatim


@node Minimum selector
@subsection Minimum selector

This selector can combine several selectors to pass an event if either 
those passes the event. It is mainly designed to generate more inclusive 
samples that, for instance, include several jet finders and that allows 
a specification later. The syntax is

@verbatim
SELECTORES:
- Type: MinSelector
  Subselectors:
  - <selector 1>
  - <selector 2>
  ...
@end verbatim

The @ref{Minimum selector} can be used if constructed with other 
selectors mentioned in this section

(*) If FastJet has not been enabled during configuration of your Sherpa
installation, you can still build a FastJet-based selector plugin by including
the content of any necessary functions (e.g. from @code{Fastjet_Helpers.@{H,C@}})
explicitly and linking against FastJet at compile time of the plugin.
