#include "CFPSHOWER++/Kinematics/Kinematics_Base.H"
#include "CFPSHOWER++/Shower/Kernel.H"
#include "CFPSHOWER++/Tools/Parton.H"
#include "ATOOLS/Math/Poincare.H"
#include "ATOOLS/Org/Message.H"

namespace CFPSHOWER {
  class FF_PanGlobal_Kinematics : public Kinematics_Base {
  private:
    Parton      * p_split, * p_spect;
    ATOOLS::Vec4D m_splitmom, m_spectmom, m_newmom; 
    double        m_zi, m_zj, m_u2, m_u;
    std::map<Parton *,ATOOLS::Vec4D> m_momenta_map;

    bool MakeZiZj(Splitting & split);
    void ConstructK(Splitting & split);
    void MakeSystem(Splitting & split,const Configuration & config); 
    void BoostMomenta(Splitting & split);
    bool CheckKT2(Splitting & split);
    bool CheckKinematics(Splitting & split,Configuration & config);
    static ATOOLS::Vec4D NT(const ATOOLS::Vec4D &a,
			    const ATOOLS::Vec4D &b);
    static ATOOLS::Vec4D LT(const ATOOLS::Vec4D &a,
			    const ATOOLS::Vec4D &b,
			    const ATOOLS::Vec4D &c);
  public:
    FF_PanGlobal_Kinematics(const Kernel_Info & info);
    void Init(const Splitting & split, Configuration & config,
	      const ATOOLS::Mass_Selector * msel);
    bool operator()(Splitting & split, Configuration & config);
    void CalculateInvariants(Splitting & split, Configuration & config);
    void CalculateJacobean(Splitting & split,Configuration & config);
    bool UpdateSystem(Splitting & split, Configuration & config);
  };
}

using namespace CFPSHOWER;
using namespace ATOOLS;

FF_PanGlobal_Kinematics::FF_PanGlobal_Kinematics(const Kernel_Info & info)  :
  Kinematics_Base(info)
{
  SetName("FF: PanGlobal Kinematics");
  SetScheme(kin_type::PanGlobal);
}

void FF_PanGlobal_Kinematics::Init(const Splitting & split, Configuration & config,
				   const Mass_Selector * msel) {
  p_split    = split.GetSplitter();
  p_spect    = split.GetSpectator();
  m_splitmom = p_split->Mom();
  m_spectmom = p_spect->Mom();
  m_weight   = 0.;
  m_allmomenta.clear();
  m_allmasses2.clear();
}

bool FF_PanGlobal_Kinematics::operator()(Splitting & split, Configuration & config) {
  //msg_Out()<<"-----------------------------------------------------\n"
  //	   <<"-----------------------------------------------------\n"
  //	   <<METHOD<<" for t = "<<split.T()<<", y = "<<split.Y()<<" "
  //	   <<"and phi = "<<split.Phi()<<" for\n"<<config<<"\n";
  if (!MakeZiZj(split)) return false;
  ConstructK(split);
  MakeSystem(split,config);
  BoostMomenta(split);
  if (!CheckKT2(split)) return false;
  SF_Base * sf = split.GetKernel()->GetSF();
  split.SetMom(0,m_splitmom);
  split.SetMom(1,m_newmom);
  split.SetMom(2,m_spectmom);
  //msg_Out()<<METHOD<<" with new momenta:\n"
  //	   <<m_splitmom<<" + "<<m_newmom<<" + "<<m_spectmom<<"\n";
  return true;
}

bool FF_PanGlobal_Kinematics::MakeZiZj(Splitting & split) {
  double sinhy = (exp(split.Eta()) - exp(-split.Eta()))/2.;
  double sij   = 2.*m_splitmom*m_spectmom;
  double arg   = sqrt(sinhy*sinhy + sij/split.T());
  m_zi     = 1. + split.T()/sij * exp(split.Eta())  * (sinhy - arg);
  m_zj     = 1. - split.T()/sij * exp(-split.Eta()) * (sinhy + arg);
  //msg_Out()<<METHOD<<" yields zi = "<<m_zi<<", zj = "<<m_zj<<"\n";
  return (m_zi>0. && m_zj>0.);
}

bool FF_PanGlobal_Kinematics::CheckKT2(Splitting & split) {
  return true;
  double kt2 = (m_splitmom*m_newmom)*(m_spectmom*m_newmom)/(m_splitmom*m_spectmom);
  //msg_Out()<<METHOD<<": kt2 = "<<kt2<<"\n";
  if (kt2>split.Tcut()) return true;
  return false;
}


void FF_PanGlobal_Kinematics::ConstructK(Splitting & split) {
  Vec4D nt = NT(m_splitmom,m_spectmom);
  Vec4D lt = LT(m_splitmom,m_spectmom,nt);
  nt *= 1./nt.PSpat();
  lt *= 1./sqrt(dabs(lt.Abs2()));
  Vec4D kt = sqrt(split.T()) * (nt * cos(split.Phi()) + lt * sin(split.Phi()));
  m_newmom = (1.-m_zi)*m_splitmom + (1.-m_zj)*m_spectmom + kt;
  //msg_Out()<<METHOD<<" constructs k = "<<m_newmom<<" ("<<m_newmom.Abs2()<<")\n"
  //	   <<"   from nt = "<<nt<<" ("<<nt.Abs2()<<"),\n"
  //	   <<"   and lt  = "<<lt<<" ("<<lt.Abs2()<<")\n";
}
  
Vec4D FF_PanGlobal_Kinematics::NT(const Vec4D &a,const Vec4D &b) {
  Vec3D c = cross(Vec3D(a),Vec3D(b));
  if (c.Sqr() < 1.e-6) c = cross(Vec3D(a),Vec3D::XVEC);
  if (c.Sqr() < 1.e-6) c = cross(Vec3D(a),Vec3D::YVEC);
  if (c.Sqr() < 1.e-6) c = cross(Vec3D(a),Vec3D::ZVEC);
  return Vec4D(0.,c);
}

Vec4D FF_PanGlobal_Kinematics::LT(const Vec4D &a,const Vec4D &b,const Vec4D &c) {
  double b1c2 = b[1]*c[2]-b[2]*c[1], b0c2 = b[0]*c[2]-b[2]*c[0];
  double b2c3 = b[2]*c[3]-b[3]*c[2], b0c1 = b[0]*c[1]-b[1]*c[0];
  double b3c1 = b[3]*c[1]-b[1]*c[3], b3c0 = b[3]*c[0]-b[0]*c[3];
  
  double t =  a[1]*b2c3 + a[2]*b3c1 + a[3]*b1c2;
  double x = -a[0]*b2c3 - a[2]*b3c0 - a[3]*b0c2;
  double y = -a[0]*b3c1 + a[1]*b3c0 + a[3]*b0c1;
  double z = -a[0]*b1c2 + a[1]*b0c2 - a[2]*b0c1;
  return Vec4D(t,-x,-y,-z);
}

void FF_PanGlobal_Kinematics::MakeSystem(Splitting & split,const Configuration & config) {
  Vec4D cmstot(0.,0.,0.,0.), systot(0.,0.,0.,0.), shifted(0.,0.,0.,0.); 
  for (Parton_List::const_iterator pit=config.begin();pit!=config.end();pit++) {
    if ((*pit)->On() && (*pit)->Flav().Strong()) {
      cmstot += (*pit)->Mom();
      if ((*pit)!=split.GetSplitter() && (*pit)!=split.GetSpectator())
	shifted += (*pit)->Mom();
    }
  }
  shifted += m_zi * split.GetSplitter()->Mom() +  m_zj * split.GetSpectator()->Mom() + m_newmom;
  m_u2 = cmstot.Abs2()/shifted.Abs2();
  m_u  = sqrt(m_u2);
  //msg_Out()<<"   scale factor = "<<m_u<<" from "<<cmstot<<"/"<<shifted<<"\n";
  for (Parton_List::const_iterator pit=config.begin();pit!=config.end();pit++) {
    if (!(*pit)->On() || !(*pit)->Flav().Strong() ||
	(*pit)==p_split || (*pit)==p_spect) continue;
    Vec4D mom = m_u * (*pit)->Mom();
    mom[0]    = dabs(mom.PSpat()); 
    systot   += mom;
  }
  m_splitmom    *= m_zi * m_u;
  m_splitmom[0]  = m_splitmom.PSpat();
  m_spectmom    *= m_zj * m_u;
  m_spectmom[0]  = m_spectmom.PSpat();
  m_newmom      *= m_u;
  m_newmom[0]    = m_newmom.PSpat();
  systot        += m_splitmom + m_spectmom + m_newmom;
  split.SetCMSTot(cmstot);
  split.SetSysTot(systot);
  split.SetMomScale(m_u);
}
  
void FF_PanGlobal_Kinematics::BoostMomenta(Splitting & split) {
  Poincare sysboost(split.GetSysTot()), cmsboost(split.GetCMSTot());
  sysboost.Boost(m_splitmom);
  cmsboost.BoostBack(m_splitmom);
  sysboost.Boost(m_spectmom);
  cmsboost.BoostBack(m_spectmom);
  sysboost.Boost(m_newmom);
  cmsboost.BoostBack(m_newmom);
}

void FF_PanGlobal_Kinematics::CalculateInvariants(Splitting & split,Configuration & config) {
}

void FF_PanGlobal_Kinematics::CalculateJacobean(Splitting & split,Configuration & config) {
  m_weight  = pow(m_u2,config.NPartons()+1) * sqr(m_zi*m_zj);
  m_weight *= ( split.GetCMSTot().Abs2() /
		(split.GetCMSTot() * (split.GetCMSTot()-split.Mom(1))) );
}

bool FF_PanGlobal_Kinematics::UpdateSystem(Splitting & split,Configuration & config) {
  Poincare sysboost(split.GetSysTot()), cmsboost(split.GetCMSTot());
  double momscale = split.MomScale();
  m_momenta_map.clear();
  for (Parton_List::const_iterator pit=config.begin();pit!=config.end();pit++) {
    if (!(*pit)->On() || !(*pit)->Flav().Strong()) continue;
    if ((*pit)==split.GetSpectator()) m_momenta_map[(*pit)] = split.Mom(2);
    else if ((*pit)!=split.GetParton(0) && (*pit)!=split.GetParton(1)) {
      Vec4D mom = momscale * (*pit)->Mom();
      mom[0] = dabs(mom.PSpat()); 
      sysboost.Boost(mom);
      cmsboost.BoostBack(mom);
      m_momenta_map[(*pit)] = mom;
    }
  }
  for (size_t i=0;i<2;i++) m_momenta_map[split.GetParton(i)] = split.GetParton(i)->Mom();
  if (CheckKinematics(split,config)) {
    for (std::map<Parton*, Vec4D>::iterator pmit=m_momenta_map.begin();
	 pmit!=m_momenta_map.end();pmit++) {
      pmit->first->SetMom(pmit->second);
    }
    return true;
  }
  return false;
}

bool FF_PanGlobal_Kinematics::CheckKinematics(Splitting & split,Configuration & config) {
  Vec4D newsum(0.,0.,0.,0.);
  for (std::map<Parton*, Vec4D>::iterator pmit=m_momenta_map.begin();
       pmit!=m_momenta_map.end();pmit++) newsum += pmit->second;
  Vec4D check = split.GetCMSTot()-newsum;
  if (dabs(check.Abs2())>1.e-6 || dabs(check[0])>1.e-3) {
    msg_Error()<<"\n"<<METHOD<<" throws momentum conservation error: check = "<<check<<"\n";
    for (std::map<Parton*, Vec4D>::iterator pmit=m_momenta_map.begin();
	 pmit!=m_momenta_map.end();pmit++) {
      if (pmit->first==split.GetParton(0) ||
	  pmit->first==split.GetParton(1)) {
	msg_Out()<<"   add  "<<pmit->first->Flav()<<": "
		 <<pmit->first->Mom()<<" --> "<<pmit->second<<".\n";
      }
      else {
	msg_Out()<<"   move "<<pmit->first->Flav()<<": "
		 <<pmit->first->Mom()<<" --> "<<pmit->second<<".\n";
      }
    }
    msg_Out()<<"   *** momscale = "<<split.MomScale()<<"\n"<<config<<"\n";
    return false;
  }
  return true;
}

DECLARE_GETTER(FF_PanGlobal_Kinematics,"Kinematics_FF_PanGlobal",Kinematics_Base,Kernel_Info);

Kinematics_Base * Getter<Kinematics_Base,Kernel_Info,FF_PanGlobal_Kinematics>::
operator()(const Parameter_Type & info) const
{
  if (info.Type()==kernel_type::FF &&
      info.KinType()==kin_type::PanGlobal &&
      info.LogType()==log_type::soft) {
    return new FF_PanGlobal_Kinematics(info);
  }
  return NULL;
}

void Getter<Kinematics_Base,Kernel_Info,FF_PanGlobal_Kinematics>::
PrintInfo(std::ostream &str,const size_t width) const
{
  str<<"PanGlobal Kinematics (FF)";
}


