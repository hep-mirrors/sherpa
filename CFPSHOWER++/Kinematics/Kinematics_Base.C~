#include "CFPSHOWER++/Kinematics/Kinematics_Base.H"
#define COMPILE__Getter_Function
#define PARAMETER_TYPE CFPSHOWER::Kernel_Info
#define OBJECT_TYPE    CFPSHOWER::Kinematics_Base
#define SORT_CRITERION std::less<std::string>
#include "ATOOLS/Org/Getter_Function.C"
#include "ATOOLS/Org/Message.H"

using namespace CFPSHOWER;
using namespace ATOOLS;

Kinematics_Base::Kinematics_Base(const Kernel_Info & info) :
  m_name("unknown")
{}

Kinematics_Base::~Kinematics_Base() {}

/*
void Kinematics_Base::Init(const Splitting & split) {
  m_psplit = split.GetSplitter()->Mom();
  m_pspect = split.GetSpectator()->Mom();
  m_pboth  = m_psplit+m_pspect;
  m_Q2     = m_pboth.Abs2();
  m_Q      = sqrt(m_Q2);
  m_weight = 0.;
}
*/

Vec4D Kinematics_Base::SumMomenta(const Configuration & config) {
  Vec4D momsum(0.,0.,0.,0.);
  for (Parton_List::const_iterator pit=config.begin();pit!=config.end();pit++) {
    momsum += (*pit)->Mom();
  }
  return momsum;
}

Vec4D Kinematics_Base::LT(const Vec4D &a,const Vec4D &b,const Vec4D &c) {
  double b1c2 = b[1]*c[2]-b[2]*c[1], b0c2 = b[0]*c[2]-b[2]*c[0];
  double b2c3 = b[2]*c[3]-b[3]*c[2], b0c1 = b[0]*c[1]-b[1]*c[0];
  double b3c1 = b[3]*c[1]-b[1]*c[3], b3c0 = b[3]*c[0]-b[0]*c[3];
  
  double t =  a[1]*b2c3 + a[2]*b3c1 + a[3]*b1c2;
  double x = -a[0]*b2c3 - a[2]*b3c0 - a[3]*b0c2;
  double y = -a[0]*b3c1 + a[1]*b3c0 + a[3]*b0c1;
  double z = -a[0]*b1c2 + a[1]*b0c2 - a[2]*b0c1;
  return Vec4D(t,-x,-y,-z);
}

double Kinematics_Base::Lambda(const double & a,const double & b,const double & c) {
  double lambda2 = Lambda2(a,b,c); 
  if (lambda2<0.) {
    msg_Error()<<"Error in "<<METHOD<<"("<<a<<", "<<b<<", "<<c<<") yields nan.\n"
	       <<"   return 0. and hope for the best.\n";
    return 0.;
  }
  return sqrt(lambda2);
}

double Kinematics_Base::Lambda2(const double & a,const double & b,const double & c) {
  return sqr(a-b-c)-4.*b*c;
}

