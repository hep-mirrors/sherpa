#include "CFPSHOWER++/Shower/Splitting.H"
#include "CFPSHOWER++/Tools/Configuration.H"
#include "CFPSHOWER++/Tools/Kernel_Info.H"
#include "ATOOLS/Org/Message.H"
#include "ATOOLS/Org/Exception.H"

using namespace CFPSHOWER;
using namespace ATOOLS;
using namespace std;

Configuration::Configuration(const double & t, const double & t0) :
  p_ampl(NULL), m_t(t), m_t0(t0) {}

Configuration::Configuration(Cluster_Amplitude * const ampl,
			     map<Cluster_Leg*,Parton*> & lmap,
			     Cluster_Definitions * cluster) :
  p_ampl(ampl), m_t(p_ampl->KT2()), m_t0(-1.), m_pos(Vec4D(0.,0.,0.,0.))
{
  if (!p_ampl) return;
  Fill(lmap);
  if (p_ampl->Prev()) m_tveto = p_ampl->Prev()->KT2();
}

void Configuration::Fill(map<Cluster_Leg*,Parton*> & lmap) {
  for (size_t i(0);i<p_ampl->Legs().size();++i) {
    Cluster_Leg *leg = p_ampl->Leg(i);
    Parton *parton = new Parton(leg->Flav(),leg->Mom());
    parton->SetColor(Color(leg->Col().m_i,leg->Col().m_j));
    push_back(parton);
    if (i<p_ampl->NIn()) parton->SetBeam(leg->Mom()[3]>0.?2:1);
    lmap[leg] = parton;
  }
  EstablishRelations();
}

void Configuration::EstablishRelations() {
  for (Parton_List::iterator pit=begin();pit!=end();pit++) {
    for (Parton_List::iterator spec=begin();spec!=end();spec++) {
      if ((*pit)==(*spec)) continue;
      for (size_t i=0;i<2;i++) {
	if ((*pit)->GetColor()[i]!=0 &&
	    (*pit)->GetColor()[i]==(*spec)->GetColor()[1-i])
	  (*pit)->AddSpectator(*spec);
      }
    }
  }
}

void Configuration::EstablishHistories(map<Cluster_Leg*,Parton*> & lmap,
				       Cluster_Definitions * cluster) {
  // "inner" is the Cluster_Amplitude before one leg splitting results in p_ampl.
  // The name of the game is to reconstruct this splitting and translate it into
  // the language of the parton shower, to fix the starting conditions for the
  // configuration emerging from p_ampl.  If there is no "inner" Cluster_Amplitude,
  // p_ampl is the hardest one, and the starting conditions are given by the
  // scale mu_Q set externally.
  Cluster_Amplitude * inner = p_ampl->Next();
  if (inner) {
    // lij denotes the splitting leg, ic, jc, and kc are the id numbers for the
    // two offsprings and the spectator:  ij+k -> i+j+k
    int ic=-1,jc=-1,kc=-1;
    Cluster_Leg * splitter(NULL);
    Cluster_Leg * newleg(p_ampl->IdLeg(p_ampl->IdNew()));
    // Look for splitter in inner - the parton where a spectator K has been assigned.
    for (size_t i=0; i<inner->Legs().size()&&splitter==NULL; ++i) {
      if (inner->Leg(i)->K()) splitter = inner->Leg(i);
    }
    if (splitter==NULL) THROW(fatal_error,"Invalid PS tree");
    // Iterate through the legs of the "harder" amplitude ("inner") and the emerging
    // amplitude ("p_ampl").  inner should provide a leg splitting into one of the
    // p_ampl legs, allowing us to successively reconstruct ic, jc, and kc.
    for (size_t i=0;i<inner->Legs().size();++i) {
      Cluster_Leg * inleg(inner->Leg(i));
      Parton      * inpart = lmap[inleg];
      for (size_t j=0;j<p_ampl->Legs().size();++j) {
	Cluster_Leg * outleg(p_ampl->Leg(j));
	// If the out leg comes from the in leg, they have a common
	// bit in their Id - this is when we start reconstructing the splitting.
	// This is somewhat tricky, as there are two cases:
	// - inleg==splitter:
	//   then outleg is either the newleg or not, and, correspondingly, outleg is
	//   either j or or i.
	// - outleg = spectator (splitter->K()):
	//   then outleg is k.
	// In both cases we establish that inpart is the incoming parton to outpart,
	// while outpart is the incoming parton to inpart.
	if (inleg->Id() & outleg->Id()) {
	  // Is the out leg the spectator?
	  if (outleg->Id()==splitter->K()) kc=j;
	  Parton * outpart = lmap[outleg];
	  // Establish the relations between the splitter and out partons
	  if (inpart->Out(0)) {
	    if (inpart->Out(1)) THROW(fatal_error,"Invalid PS tree");
	    if (inleg==splitter) (outleg==newleg?jc:ic)=j;
	    inpart->SetOut(1,outpart);
	    outpart->SetIn(inpart);
	  }
	  else {
	    if (inleg==splitter) (outleg==newleg?jc:ic)=j;
	    inpart->SetOut(0,outpart);
	    outpart->SetIn(inpart);
	  }
	}
      }
    }
    if (ic<0 || jc<0 || kc<0) THROW(fatal_error,"Invalid PS tree");
    // Now we are in the position to reconstruct the actual splitting
    double ws, mu2;
    int flip(jc<ic), swap(jc<p_ampl->NIn() && flip);
    if (swap) std::swap<int>(ic,jc);

    kernel_type::code type = GetCode(ic<p_ampl->NIn(),kc<p_ampl->NIn());
    Splitting split  = cluster->KT2(*p_ampl,ic,jc,kc,splitter->Flav(),inner->Kin(),
				    type,1|(swap?2:0)|(inner->NLO()?16<<2:0),ws,mu2);
    split.SetSpectator(lmap[inner->IdLeg(splitter->K())]);
    split.SetSplitter(lmap[splitter]);
  }
}


Configuration::~Configuration() {
  while (!empty()) {
    if (front()) delete (front());
    pop_front();
  }
}

std::ostream &CFPSHOWER::operator<<(std::ostream & s,const Configuration & config) {
  s<<"Configuration with "<<config.size()<<" partons for evolution "
   <<"from "<<config.T()<<" to "<<config.T0()<<":\n";
  for (Parton_List::const_iterator pit=config.begin();pit!=config.end();pit++) s<<(**pit);
  return s;
}
