#include "CFPSHOWER++/Tools/Kernel_Constructor.H"
#include "CFPSHOWER++/Shower/Shower.H"
#include "CFPSHOWER++/Shower/Kernel.H"
#include "CFPSHOWER++/SplittingFunctions/SF_Base.H"
#include "CFPSHOWER++/Shower/Cluster_Definitions.H"
#include "CFPSHOWER++/Tools/Kernel_Info.H"
#include "MODEL/Main/Model_Base.H"
#include "MODEL/Main/Single_Vertex.H"
#include "MODEL/Main/Running_AlphaS.H"
#include "PDF/Main/ISR_Handler.H"
#include "ATOOLS/Org/Message.H"
//#include "ATOOLS/Org/Scoped_Settings.H"


using namespace CFPSHOWER;
using namespace MODEL;
using namespace ATOOLS;
using namespace std;

Kernel_Constructor::Kernel_Constructor(Shower * shower): p_shower(shower) {}

Kernel_Constructor::~Kernel_Constructor() { }

bool Kernel_Constructor::
Init(MODEL::Model_Base * const model,PDF::ISR_Handler * const isr)
{
  // Shower parameters and switches are pulled from the map in CFP_Parameter
  // - parton shower cutoffs for FS and IS showering
  // - order of the splitting function and details of terms included
  // - scale setting schemes
  // - eventually recoil schemes
  msg_Out()<<"Entering "<<METHOD<<" ===========================\n";
  m_kinscheme   = 1; // 1 = Alaric, 2 = CS
  m_SForder     = 1; // order as = 1
  m_logtype     = 2; // this needs working, atm: 1 = soft only, 2 = both
  m_kfactor     = 0; // order as = 1
  m_muRscheme   = 1;
  m_softcorr    = 0;
  m_endpoint    = 0;
  m_cplscheme   = 1;
  m_MEcorrs     = 0;
  m_asfactor[0] = 1.;
  m_asfactor[1] = 1.;
  m_muR2factor  = 1.;
  m_muF2factor  = 1.;
  m_pdfmin      = 1.e-4;
  m_pdfxmin     = 1.e-4;
  msg_Out()<<"=== fixed parameters and switches.\n";

  p_as    = (MODEL::Running_AlphaS*)(model->GetScalarFunction("alpha_S"));
  for (int i=0;i<2;++i) p_pdf[i]=isr->PDF(i);
  MakePermutations();
  msg_Out()<<"=== fixed permutations.\n";
  return InitializeKernels(model);
}

bool Kernel_Constructor::InitializeKernels(MODEL::Model_Base * const model) {
  //if (msg_LevelIsDebugging()) {
  msg_Out()<<"***************************************************************\n"
	   <<METHOD<<" starts collecting splitting kernels.\n"
	   <<"** available kernels:\n";
  SF_Getter::PrintGetterInfo(msg->Out(),25);
  GP_Getter::PrintGetterInfo(msg->Out(),25);
  msg_Out()<<"\n";
  //}
  // Going through vertex tables and translating 3-particle vertices into
  // splitting kernels.  The kernels consist of an actual splitting function, 
  // a gauge part, and a kinematics part.  The splitting function
  // encapsulates eikonals and/or AP splitting functions, triple-collinear
  // parts, etc.; gauge part handles the colour configuration and all aspects
  // related to the coupling constants at higher orders, and the kinematics
  // part steers the creation of the momenta in the splitting and how they
  // are compensated by the rest of the event.
  // The set of flavour triplets makes sure we do not initialize splitting
  // kernels for any parton configuration more than once.

  for (size_t i=0;i<5;i++) p_kernels[i] = new map<Flavour, Kernels *>;
 
  MakeKernelsFromVertices(model);
  if (msg_LevelIsDebugging()) PrintKernels();
  
  if (abs(m_SForder)>1) {
    msg_Out()<<"*********************************************************\n"
    	     <<"Now start collating 1->2 kernels into 1->3 kernels.\n"
    	     <<"*********************************************************\n";
    for (size_t type=1;type<2;type++)
      MakeKernelsFromKernels(kernel_type::code(type));
    if (m_SForder<0) DeleteAllKernelsWithWrongOrder();
  }
  if (msg_LevelIsDebugging()) PrintKernels(true);
  msg_Out()<<"=== initialised kernels.\n";
  return true;
}

void Kernel_Constructor::
MakeKernelsFromVertices(MODEL::Model_Base * const model) {
  set<vector<Flavour> > constructed;
  const Vertex_Table *vtab(model->VertexTable());
  for (Vertex_Table::const_iterator vlit=vtab->begin();
       vlit!=vtab->end();++vlit) {
    msg_Debugging()<<"**** vertices for "<<vlit->first<<"\n";
    if (!vlit->first.IsQuark() && !vlit->first.IsGluon()) continue;
    for (Vertex_List::const_iterator vit=vlit->second.begin();
	 vit!=vlit->second.end();++vit) {
      MODEL::Single_Vertex * vertex = (*vit);
      // At LO only 3-particle vertices are allowed and we keep track of such
      // configurations only in the kernel_flavours set.  
      if (vertex->NLegs()>3) continue;
      if (constructed.find(vertex->in)!=constructed.end()) return;
      constructed.insert(vertex->in);
      for (size_t type=1;type<2;type++) {
	for (size_t logtype=1;logtype<m_logtype+1;logtype++) {
	  MakeKernels(vertex->in,log_type::code(logtype),
		      kernel_type::code(type));
	}
      }
    }
  }
}

void Kernel_Constructor::
MakeKernels(Flavour_Vector & flavs,
	    const log_type::code & logtype,
	    const kernel_type::code & type) {
  // The kernels are initialised with the information stored in the Kernel_Info
  // struct, which carries information about:
  // - the flavours, 
  // - their configuration for splitter/spectator in the kernel_type struct
  //   (FF, FI, IF, and II)
  // - pointers to alphaS and alpha(QED)
  // - the tagging sequence
  // - to be implemented: order information, masses of particles, etc..
  // Initialised kernels are organised in 4 maps (one for each of the
  // splitter/spectator configurations), connecting splitting flavours
  // with all possible kernels.
  Flavour split = flavs[0].Bar();
  Flavour_Vector newflavs; 
  for (size_t i=1;i<flavs.size();i++) newflavs.push_back(flavs[i]); 
  size_t order  = newflavs.size()-1;
  if (flavs.size()>3) {
    //msg_Out()<<"  * "<<METHOD<<"["<<type<<", "
    // <<kin_type::code(m_kinscheme)<<", "
    //	     <<"order = "<<order<<"] for "<<split<<" -> ";
    //for (size_t i=0;i<newflavs.size();i++) msg_Out()<<newflavs[i]<<" ";
    //msg_Out()<<" with "<<m_permutations[order-1].size()<<" permutations.\n";
  }
  for (list<vector<size_t> >::iterator lit=m_permutations[order-1].begin();
       lit!=m_permutations[order-1].end();lit++) {
    //msg_Out()<<METHOD<<" with "<<muR_scheme::code(m_muRscheme)<<" from "
    //<<m_muRscheme<<"\n";
    Kernel_Info info(split,newflavs,(*lit),logtype,
		     kin_type::code(m_kinscheme),
		     muR_scheme::code(m_muRscheme),
		     kernel_type::code(type));
    info.SetAlphaS(p_as);
    info.SetKFactor(m_kfactor);
    info.SetSoftCorrection(m_softcorr);
    info.SetEndpoint(m_endpoint);
    info.SetCplScheme(m_cplscheme);
    info.SetAsFactor(((type==kernel_type::FF || type==kernel_type::FI) ?
		      m_asfactor[0] : m_asfactor[1]));
    info.SetMuR2Factor(m_muR2factor);
    //if (flavs.size()>3) msg_Out()<<"     * looking for kernel for "<<info;
    Kernel * kernel = Kernel_Getter::GetObject("Kernel",info);
    if (kernel==0) continue;
    if (p_kernels[int(info.Type())]->find(info.GetSplit())==
	p_kernels[int(info.Type())]->end()) {
      /*
	if (flavs.size()>3) {
        msg_Out()<<"     * Init new kernel list for type = "<<info.Type()
	<<" & flav = "<<info.GetSplit()<<": "<<info;
	}
      */
      (*p_kernels[int(info.Type())])[info.GetSplit()] = new Kernels();
    }
    (*p_kernels[int(info.Type())])[info.GetSplit()]->push_back(kernel);
    /*
      if (newflavs.size()>2) {
      msg_Out()<<"     * Add kernel to ["<<info.Type()<<"]["<<info.GetSplit()<<"]: "
      <<info;
    }
    */
    for (size_t beam = 0;beam<2;beam++) kernel->SetPDF(beam,p_pdf[beam]);
    kernel->SetPDFMinValue(m_pdfmin);
    kernel->SetPDFXMin(m_pdfxmin);
    kernel->SetMSel(p_shower->GetMassSelector());
    kernel->SetEnhanceFactor(1.);
    //order==1?1.:(*cfp_pars)("NLO_enhance"));
  }
}

void Kernel_Constructor::MakeKernelsFromKernels(const kernel_type::code & type) {
  //msg_Out()<<METHOD<<"["<<type<<"]:\n";
  if (type==kernel_type::IF || type==kernel_type::II) {
    msg_Out()<<METHOD<<" for initial state kernels.  "
	     <<"Will have to think about this.\n";
    exit(1);
  }
  // Iterate over all 1->2 kernels and see if you can attach another 1->2 kernel
  // to the outgoing particles/flavours - based on all kernels of a given type and
  // kernels for FF splittings
  map<Flavour,Kernels *> * allkernels = p_kernels[int(type)];
  map<Flavour,Kernels *> * ffkernels  = p_kernels[int(kernel_type::FF)];
  // initiate a look-up table of "vetoed" flavour combination, to make sure we 
  // have every combination of four flavours only once
  set<multiset<Flavour> > additions;
  for (map<Flavour,Kernels *>::iterator allkit=allkernels->begin();
       allkit!=allkernels->end();allkit++) {
    const Flavour & splitter    = allkit->first;
    const Kernels * flavkernels = allkit->second;
    //msg_Out()<<"*** Iterate over "<<flavkernels->size()<<" "
    //	     <<"kernels for splitter = "<<splitter<<".\n";
    size_t kpos = 0;
    for (Kernel_Vector::const_iterator kit=flavkernels->begin();
	 kit!=flavkernels->end();kit++) {
      kpos++;
      // if all kernels come in up to two variants, some may not have a soft part,
      // but all will have a collinear part - so we can ignore the soft kernels.
      if ((*kit)->Tags()[0]==1) continue;
      Flavour_Vector outs = (*kit)->GetFlavs();
      // go over the two outgoing flavours and produce trial final states by keeping
      // one and replacing the other with two outgoing flavours from the already
      // initialised 1->2 ffkernels.
      for (size_t j=0;j<2;j++) {
	//msg_Out()<<"  * replace flavour "<<j<<" in "<<splitter
	//	 <<" --> "<<outs[0]<<" + "<<outs[1]<<"\n";
	if (ffkernels->find(outs[j])==ffkernels->end()) continue;
	Kernel_Vector * replkernels = (*ffkernels)[outs[j]];
	for (size_t k=0;k<replkernels->size();k++) {
	  Kernel * rkernel = (*replkernels)[k];
	  // only use 1->2 kernels in the construction
	  if (rkernel->GetFlavs().size()>2) continue;
	  // produce a trial final state:
	  // insert the flavour that is not going to be replaced and the outgoing 
	  // flavours of the already existing ffkernel with the other flavour as
	  // incoming flavour
	  multiset<Flavour> trial;
	  trial.insert(outs[1-j]);
	  for (size_t f=0;f<rkernel->GetFlavs().size();f++)
	    trial.insert(rkernel->GetFlavs()[f]);
	  // check if we already have this combination and if new insert into 
	  // table of combinations to be added
	  if (additions.find(trial)==additions.end()) {
	    /*
	      msg_Out()<<"    * add "<<splitter<<" -> "<<outs[1-j]<<" ";
	      for (size_t f=0;f<rkernel->GetFlavs().size();f++)
	      msg_Out()<<rkernel->GetFlavs()[f]<<" ";
	      msg_Out()<<"\n";
	    */
	    additions.insert(trial);
	  }
	}
      }
    }
    set<multiset<Flavour> >::iterator sit=additions.begin();
    while (!additions.empty()) {
      Flavour_Vector flavs;
      // Have to bar splitter due to structure of vertices entering MakeKernels.
      // This will be barred again in that method.
      flavs.push_back(splitter.Bar());
      for (multiset<Flavour>::iterator fit=sit->begin();fit!=sit->end();fit++)
	flavs.push_back(*fit);
      for (size_t logtype=1;logtype<m_logtype+1;logtype++) {
	MakeKernels(flavs,log_type::code(logtype),type);
      }
      sit = additions.erase(sit);
    }
  }
}

void Kernel_Constructor::DeleteAllKernelsWithWrongOrder() {
  size_t critFS = abs(m_SForder)+1;
  for (size_t i=1;i<5;i++) {
    if (p_kernels[i]->size()==0) continue;
    msg_Out()<<"--------------------------------------------------\n"
    	     <<"--- Delete Kernels for type = "<<i<<" with "
    	     <<critFS<<" outgoing particles:\n";
    for (map<Flavour,Kernels *>::iterator ksit=p_kernels[i]->begin();
	 ksit!=p_kernels[i]->end();ksit++) {
      msg_Out()<<"--- flavour = "<<ksit->first<<"\n";
      Kernel_Vector * kernels = ksit->second;
      Kernel_Vector::iterator kit = kernels->begin();
      while (kit!=kernels->end()) {
	if ((*kit)->GetFlavs().size()!=critFS) {
	  msg_Out()<<"  * delete : "<<(**kit);
	  delete (*kit);
	  kit = kernels->erase(kit);
	}
	else {
	  msg_Out()<<"  * keep   : "<<(**kit);
	  kit++;
	}
      }
    }
    msg_Out()<<"--------------------------------------------------\n";
  }
}

void Kernel_Constructor::MakePermutations() {
  size_t now = 2, pos;
  m_permutations.resize(abs(m_SForder));
  while (now<=abs(m_SForder)+1) {
    vector<size_t> perm;
    for (size_t i=0;i<now;i++) perm.push_back(i);
    pos = now;
    GeneratePermutation(perm,pos,now);
    now++;
  }
  //if (msg_LevelIsDebugging()) {
  for (size_t i=0;i<m_permutations.size();i++) {
    msg_Out()<<"####### Permutations for "<<(i+2)
	     <<" partons ##############\n";
    size_t j=1;
    msg_Out()<<"        found "<<m_permutations[i].size()<<" entries:\n";
    for (list<vector<size_t> >::iterator lit=m_permutations[i].begin();
	 lit!=m_permutations[i].end();lit++) {
      msg_Out()<<" "<<(j++)<<"th permutation = {";
      for (size_t k=0;k<lit->size();k++) msg_Out()<<" "<<(*lit)[k];
      msg_Out()<<" }\n";
    }
  }
    //}
}

void Kernel_Constructor::
GeneratePermutation(std::vector<size_t> perm,const size_t & pos,const size_t & length) {
  if (pos==1) {
    vector<size_t> newperm = perm;
    m_permutations[length-2].push_back(newperm);
  }
  else {
    GeneratePermutation(perm,pos-1,length);
    for (size_t i=0;i<pos-1;i++) {
      if (i%2) swap(perm[i], perm[pos-1]);
      else     swap(perm[0], perm[pos-1]);
      GeneratePermutation(perm,pos-1,length);
    }
  }
}

void Kernel_Constructor::PrintKernels(const bool & full) {
  for (size_t i=1;i<5;i++) {
    msg_Out()<<"--------------------------------------------------\n"
	     <<"--- Kernels for type = "<<i<<": ";
    if (!full) { msg_Out()<<p_kernels[i]->size()<<" kernels.\n"; continue; }
    if (p_kernels[i]->size()==0) { msg_Out()<<"empty.\n"; continue;}
    for (map<Flavour,Kernels *>::iterator ksit=p_kernels[i]->begin();
	 ksit!=p_kernels[i]->end();ksit++) {
      msg_Out()<<"--- flavour = "<<ksit->first<<"\n";
      for (Kernel_Vector::iterator kit=ksit->second->begin();
	   kit!=ksit->second->end();kit++) {
	msg_Out()<<"    * "<<(*kit)<<": "<<(**kit);
      }
    }
    msg_Out()<<"--------------------------------------------------\n";
  }
}

